<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaGuang</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-01-13T08:45:07.616Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>DaGuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python基础入门</title>
    <link href="http://example.com/2025/01/09/python/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2025/01/09/python/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2025-01-09T15:07:16.000Z</published>
    <updated>2025-01-13T08:45:07.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/10/1Ckhj2OT3FMxtsS.png"></p><span id="more"></span><h1 id="python基础入门"><a href="#python基础入门" class="headerlink" title="python基础入门"></a>python基础入门</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/10/1Ckhj2OT3FMxtsS.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python基础入门" scheme="http://example.com/tags/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>nvidia-smi</title>
    <link href="http://example.com/2025/01/07/%E6%99%BA%E7%AE%97/nvidia-smi/"/>
    <id>http://example.com/2025/01/07/%E6%99%BA%E7%AE%97/nvidia-smi/</id>
    <published>2025-01-07T08:58:50.000Z</published>
    <updated>2025-01-08T00:49:01.179Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/01/07/AYU87yHenGivIj5.jpg">  </p><span id="more"></span><h1 id="nvidia-smi"><a href="#nvidia-smi" class="headerlink" title="nvidia-smi"></a>nvidia-smi</h1><p>NVIDIA System Management Interface (nvidia-smi)：是 NVIDIA 提供的命令行工具，用于监控和管理 NVIDIA GPU 的状态和性能。通过nvidia-smi，你可以查看 GPU 的使用情况、温度、功率、显存占用、驱动版本等信息。<br><img src="/2025/01/07/%E6%99%BA%E7%AE%97/nvidia-smi/2025-01-07-17-24-55.png"></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><p>开启持久模式<br>开启 GPU 的持久模式（Persistence Mode）可以让 GPU 驱动在系统空闲时保持加载状态，从而减少初始化延迟并提高 GPU 的响应速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启持久模式，“0”为关闭</span></span><br><span class="line">nvidia-smi -pm 1  </span><br><span class="line"><span class="comment"># 可以通过守护进程的方式开启持久化</span></span><br><span class="line"><span class="comment"># 安装了GPU驱动后，进入到/usr/share/doc/NVIDIA_GLX-1.0/samples/目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/doc/NVIDIA_GLX-1.0/samples/</span><br><span class="line">tar -xjf nvidia-persistenced-init.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> nvidia-persistenced-init</span><br><span class="line">./install.sh</span><br><span class="line">systemctl <span class="built_in">enable</span> nvidia-persistenced.service</span><br><span class="line">systemctl is-enabled nvidia-persistenced.service</span><br><span class="line">systemctl status nvidia-persistenced</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启后可以通过nvidia-smi查看Persistence-M是否开启</span></span><br></pre></td></tr></table></figure></li><li><p>ECC<br>ECC（Error Correction Code）是一种用于检测和纠正内存中数据错误的机制。在 NVIDIA GPU 中，你可以通过 nvidia-smi 命令来启用或禁用 ECC 功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用nvidia-smi -q查看ECC相关信息</span></span><br><span class="line">    ECC Mode</span><br><span class="line">        <span class="comment"># 显示当前 ECC 模式。</span></span><br><span class="line">        Current                           : Enabled</span><br><span class="line">        <span class="comment"># Enabled 表示下次启动时 ECC 功能会启用</span></span><br><span class="line">        Pending                           : Enabled</span><br><span class="line">    ECC Errors</span><br><span class="line">        <span class="comment">#Volatile（易失性错误），这些错误是临时的，通常由瞬时干扰或环境因素引起，易失性错误计数会在 GPU 重启或驱动重新加载时自动清零</span></span><br><span class="line">        Volatile</span><br><span class="line">            <span class="comment">#Correctable表示可纠正错误，Correctable表示不可纠正错误</span></span><br><span class="line">            SRAM Correctable              : 0</span><br><span class="line">            SRAM Uncorrectable            : 0</span><br><span class="line">            DRAM Correctable              : 0</span><br><span class="line">            DRAM Uncorrectable            : 0</span><br><span class="line">        <span class="comment">#Aggregate（累积性错误），这些错误是在 GPU 生命周期内累积的，累积性错误计数不会在 GPU 重启或驱动重新加载时自动清零。</span></span><br><span class="line">        Aggregate</span><br><span class="line">            SRAM Correctable              : 0</span><br><span class="line">            SRAM Uncorrectable            : 0</span><br><span class="line">            DRAM Correctable              : 0</span><br><span class="line">            DRAM Uncorrectable            : 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#重置ECC错误计数器</span></span><br><span class="line">nvidia-smi -p 0 <span class="comment"># 重置Volatile临时错误，通常由瞬时干扰引起。</span></span><br><span class="line">nvidia-smi -p 1 <span class="comment"># 重置 Aggregate 错误计数，GPU 生命周期内累积的所有错误</span></span><br><span class="line">nvidia-smi -r <span class="comment"># 重置所有错误计数器，包括 Volatile 和 Aggregate 错误。</span></span><br></pre></td></tr></table></figure></li><li><p>查看GPU拓扑结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># nvidia-smi topo -m</span></span><br><span class="line">        GPU0    GPU1    GPU2    GPU3    GPU4    GPU5    GPU6    GPU7    NIC0    NIC1    NIC2    CPU Affinity    NUMA Affinity   GPU NUMA ID</span><br><span class="line">GPU0     X      PIX     PXB     PXB     SYS     SYS     SYS     SYS     NODE    NODE    PXB     0-31    0               N/A</span><br><span class="line">GPU1    PIX      X      PXB     PXB     SYS     SYS     SYS     SYS     NODE    NODE    PXB     0-31    0               N/A</span><br><span class="line">GPU2    PXB     PXB      X      PXB     SYS     SYS     SYS     SYS     NODE    NODE    PXB     0-31    0               N/A</span><br><span class="line">GPU3    PXB     PXB     PXB      X      SYS     SYS     SYS     SYS     NODE    NODE    PIX     0-31    0               N/A</span><br><span class="line">GPU4    SYS     SYS     SYS     SYS      X      PIX     PXB     PXB     SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">GPU5    SYS     SYS     SYS     SYS     PIX      X      PXB     PXB     SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">GPU6    SYS     SYS     SYS     SYS     PXB     PXB      X      PXB     SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">GPU7    SYS     SYS     SYS     SYS     PXB     PXB     PXB      X      SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">NIC0    NODE    NODE    NODE    NODE    SYS     SYS     SYS     SYS      X      PIX     NODE</span><br><span class="line">NIC1    NODE    NODE    NODE    NODE    SYS     SYS     SYS     SYS     PIX      X      NODE</span><br><span class="line">NIC2    PXB     PXB     PXB     PIX     SYS     SYS     SYS     SYS     NODE    NODE     X</span><br><span class="line"></span><br><span class="line">Legend:</span><br><span class="line">  <span class="comment"># 设备自身</span></span><br><span class="line">  X    = Self</span><br><span class="line">  <span class="comment"># 跨 NUMA 节点的设备之间，通信路径较长，可能涉及 CPU 和高速互联（如 Intel 的 QPI 或 AMD 的 UPI）</span></span><br><span class="line">  SYS  = Connection traversing PCIe as well as the SMP interconnect between NUMA nodes (e.g., QPI/UPI)</span><br><span class="line">  <span class="comment"># PCIe 以及 同一 NUMA 节点内 PCIe 主机桥（PHB）之间的互连，同一 NUMA 节点内的设备之间，通信路径较短，性能优于 SYS</span></span><br><span class="line">  NODE = Connection traversing PCIe as well as the interconnect between PCIe Host Bridges within a NUMA node</span><br><span class="line">  <span class="comment"># 通过 PCIe 以及 一个 PCIe 主机桥（PHB）</span></span><br><span class="line">  PHB  = Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)</span><br><span class="line">  <span class="comment"># 通过 多个 PCIe 桥，但 不经过 PCIe 主机桥（PHB）</span></span><br><span class="line">  PXB  = Connection traversing multiple PCIe bridges (without traversing the PCIe Host Bridge)</span><br><span class="line">  <span class="comment"># 连接最多通过 一个 PCIe 桥，性能最佳，因为通信路径最短</span></span><br><span class="line">  PIX  = Connection traversing at most a single PCIe bridge</span><br><span class="line">  <span class="comment"># 通过 一组绑定的 NVLink，“#”表示绑定的 NVLink 数量</span></span><br><span class="line">  NV<span class="comment">#  = Connection traversing a bonded set of # NVLinks</span></span><br><span class="line"></span><br><span class="line">NIC Legend:</span><br><span class="line"></span><br><span class="line">  NIC0: mlx5_0</span><br><span class="line">  NIC1: mlx5_1</span><br><span class="line">  NIC2: mlx5_2</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2025/01/07/AYU87yHenGivIj5.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="GPU" scheme="http://example.com/categories/GPU/"/>
    
    
    <category term="nvidia-smi" scheme="http://example.com/tags/nvidia-smi/"/>
    
  </entry>
  
  <entry>
    <title>GPUDirect RDMA</title>
    <link href="http://example.com/2025/01/06/%E6%99%BA%E7%AE%97/GPUDirect-RDMA/"/>
    <id>http://example.com/2025/01/06/%E6%99%BA%E7%AE%97/GPUDirect-RDMA/</id>
    <published>2025-01-06T11:13:02.000Z</published>
    <updated>2025-01-07T08:46:40.685Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/06/%E6%99%BA%E7%AE%97/GPUDirect-RDMA/2025-01-06-19-17-09.png"></p><blockquote><p><a href="https://docs.nvidia.com/cuda/gpudirect-rdma/index.html">英伟达文档</a>  </p></blockquote><span id="more"></span><h1 id="GPUDirect-RDMA"><a href="#GPUDirect-RDMA" class="headerlink" title="GPUDirect RDMA"></a>GPUDirect RDMA</h1><p>GPUDirect RDMA 结合了 GPU 加速计算和 RDMA（Remote Direct Memory Access）技术，实现了在 GPU 和 RDMA 网络设备之间直接进行数据传输和通信的能力。它允许 GPU 直接访问 RDMA 网络设备中的数据，无需通过主机内存或 CPU 的中介。<br>GPUDirect RDMA 通过绕过主机内存和 CPU，直接在 GPU 和 RDMA 网络设备之间进行数据传输，显著降低传输延迟，加快数据交换速度，并可以减轻 CPU 负载，释放 CPU 的计算能力。另外，GPUDirect RDMA 技术允许 GPU 直接访问 RDMA 网络设备中的数据，避免了数据在主机内存中的复制，提高了数据传输的带宽利用率。  </p><ul><li>GPU 内存可以直接暴露给 RDMA 设备：InfiniBand 网卡可以直接读取或写入 GPU 内存，而无需经过 CPU 或主机内存中转。</li><li>GPU 可以间接访问其他节点的内存：虽然 GPU 本身不能直接访问远程内存，但通过 GPUDirect RDMA，InfiniBand 网卡可以直接将数据传输到远程节点的内存中（无论是 CPU 内存还是 GPU 内存）。</li><li>GPU 本身不能直接访问远程内存，但通过 GPUDirect RDMA，InfiniBand 网卡可以直接访问 GPU 内存，从而实现 GPU 与其他节点内存的高效通信。</li></ul><h2 id="GPUDirect-RDMA使用的前置条件"><a href="#GPUDirect-RDMA使用的前置条件" class="headerlink" title="GPUDirect RDMA使用的前置条件"></a>GPUDirect RDMA使用的前置条件</h2><ul><li>GPU支持GPUDirect RDMA技术：Tesla与Quadro GPU 系列产品支持GPUDirect RDMA技术。  </li><li>网卡支持GPUDirect RDMA技术：InfiniBand 网卡支持 GPUDirect RDMA 技术，例如 Mellanox 的 ConnectX 系列产品。</li><li>操作系统支持：Linux 操作系统需要安装 NVIDIA 和 Mellanox 的驱动程序。  </li><li>PCIe 拓扑结构：GPU 和 InfiniBand 网卡需要通过 PCIe 总线连接。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过此命令查看GPUDirect RDMA支持的拓扑结构信息：GPU不在NUMA内，但是优先使用NUMA Affinity对应的node0/1的内存</span></span><br><span class="line">nvidia-smi topo -m</span><br><span class="line">        GPU0    GPU1    GPU2    GPU3    GPU4    GPU5    GPU6    GPU7    NIC0    NIC1    NIC2    CPU Affinity    NUMA Affinity   GPU NUMA ID</span><br><span class="line">GPU0     X      PIX     PXB     PXB     SYS     SYS     SYS     SYS     NODE    NODE    PXB     0-31    0               N/A</span><br><span class="line">GPU1    PIX      X      PXB     PXB     SYS     SYS     SYS     SYS     NODE    NODE    PXB     0-31    0               N/A</span><br><span class="line">GPU2    PXB     PXB      X      PXB     SYS     SYS     SYS     SYS     NODE    NODE    PXB     0-31    0               N/A</span><br><span class="line">GPU3    PXB     PXB     PXB      X      SYS     SYS     SYS     SYS     NODE    NODE    PIX     0-31    0               N/A</span><br><span class="line">GPU4    SYS     SYS     SYS     SYS      X      PIX     PXB     PXB     SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">GPU5    SYS     SYS     SYS     SYS     PIX      X      PXB     PXB     SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">GPU6    SYS     SYS     SYS     SYS     PXB     PXB      X      PXB     SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">GPU7    SYS     SYS     SYS     SYS     PXB     PXB     PXB      X      SYS     SYS     SYS     32-63   1               N/A</span><br><span class="line">NIC0    NODE    NODE    NODE    NODE    SYS     SYS     SYS     SYS      X      PIX     NODE</span><br><span class="line">NIC1    NODE    NODE    NODE    NODE    SYS     SYS     SYS     SYS     PIX      X      NODE</span><br><span class="line">NIC2    PXB     PXB     PXB     PIX     SYS     SYS     SYS     SYS     NODE    NODE     X</span><br><span class="line"></span><br><span class="line">Legend:</span><br><span class="line">  <span class="comment"># 设备自身</span></span><br><span class="line">  X    = Self</span><br><span class="line">  <span class="comment"># 跨 NUMA 节点的设备之间，通信路径较长，可能涉及 CPU 和高速互联（如 Intel 的 QPI 或 AMD 的 UPI）</span></span><br><span class="line">  SYS  = Connection traversing PCIe as well as the SMP interconnect between NUMA nodes (e.g., QPI/UPI)</span><br><span class="line">  <span class="comment"># PCIe 以及 同一 NUMA 节点内 PCIe 主机桥（PHB）之间的互连，同一 NUMA 节点内的设备之间，通信路径较短，性能优于 SYS</span></span><br><span class="line">  NODE = Connection traversing PCIe as well as the interconnect between PCIe Host Bridges within a NUMA node</span><br><span class="line">  <span class="comment"># 通过 PCIe 以及 一个 PCIe 主机桥（PHB）</span></span><br><span class="line">  PHB  = Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)</span><br><span class="line">  <span class="comment"># 通过 多个 PCIe 桥，但 不经过 PCIe 主机桥（PHB）</span></span><br><span class="line">  PXB  = Connection traversing multiple PCIe bridges (without traversing the PCIe Host Bridge)</span><br><span class="line">  <span class="comment"># 连接最多通过 一个 PCIe 桥，性能最佳，因为通信路径最短</span></span><br><span class="line">  PIX  = Connection traversing at most a single PCIe bridge</span><br><span class="line">  <span class="comment"># 通过 一组绑定的 NVLink，“#”表示绑定的 NVLink 数量</span></span><br><span class="line">  NV<span class="comment">#  = Connection traversing a bonded set of # NVLinks</span></span><br><span class="line"></span><br><span class="line">NIC Legend:</span><br><span class="line"></span><br><span class="line">  NIC0: mlx5_0</span><br><span class="line">  NIC1: mlx5_1</span><br><span class="line">  NIC2: mlx5_2</span><br></pre></td></tr></table></figure></li></ul><p><strong>NUMA</strong>：非一致性内存访问，是一种内存访问技术，允许不同处理器核心或处理器模块直接访问物理内存的不同部分。在多核处理器或多处理器系统中，NUMA架构旨在减少跨处理器核心的内存访问延迟，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看CPU和NUMA的对应关系</span></span><br><span class="line">~]<span class="comment"># lscpu</span></span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                48</span><br><span class="line">On-line CPU(s) list:   0-47</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    24</span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6</span><br><span class="line">Model:                 106</span><br><span class="line">Model name:            Intel(R) Xeon(R) Gold 5318Y CPU @ 2.10GHz</span><br><span class="line">Stepping:              6</span><br><span class="line">CPU MHz:               2101.000</span><br><span class="line">CPU max MHz:           2101.0000</span><br><span class="line">CPU min MHz:           800.0000</span><br><span class="line">BogoMIPS:              4200.00</span><br><span class="line">Virtualization:        VT-x</span><br><span class="line">L1d cache:             48K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              1280K</span><br><span class="line">L3 cache:              36864K</span><br><span class="line">NUMA node0 CPU(s):     0-23</span><br><span class="line">NUMA node1 CPU(s):     24-47</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看内存与NUMA的对应关系</span></span><br><span class="line">~]<span class="comment"># numactl -H</span></span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span><br><span class="line">node 0 size: 257434 MB</span><br><span class="line">node 0 free: 201543 MB</span><br><span class="line">node 1 cpus: 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47</span><br><span class="line">node 1 size: 258027 MB</span><br><span class="line">node 1 free: 213800 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  20   <span class="comment">#表示从node0访问node1的延迟为20</span></span><br><span class="line">  1:  20  10</span><br></pre></td></tr></table></figure><h2 id="开启GPUDirect-RDMA"><a href="#开启GPUDirect-RDMA" class="headerlink" title="开启GPUDirect RDMA"></a>开启GPUDirect RDMA</h2><ul><li>Mellanox OFED（ InfiniBand驱动和软件栈）</li><li>安装GPU驱动程序、cuda工具包</li><li>内核模块：nvidia_peermem（较新的驱动）、nv_peer_memory （较旧的驱动）</li></ul><p><strong>注意：要先安装 Mellanox OFED，再安装驱动和cuda工具包，最后加载模块。确保使用 MLNX_OFED 提供的 RDMA API 进行编译。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载模块</span></span><br><span class="line">modprobe nvidia_peermem</span><br><span class="line"><span class="comment"># 检查加载是否成功</span></span><br><span class="line">lsmod | grep nvidia_peermem</span><br><span class="line"><span class="comment"># 持久化加载，如果没有/etc/modules文件，在/etc/modprobe.d/目录下创建一个新的.conf文件，然后在该文件中添加你的模块名“Mydriver”。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nvidia_peermem&quot;</span> | sudo tee -a /etc/modules</span><br><span class="line"><span class="comment"># 验证 GPUDirect RDMA，检查 gpu_direct_rdma 字段是否为1</span></span><br><span class="line">ibv_devinfo -v</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/01/06/%E6%99%BA%E7%AE%97/GPUDirect-RDMA/2025-01-06-19-17-09.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.nvidia.com/cuda/gpudirect-rdma/index.html&quot;&gt;英伟达文档&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GPU" scheme="http://example.com/categories/GPU/"/>
    
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
    <category term="RMDA" scheme="http://example.com/tags/RMDA/"/>
    
  </entry>
  
  <entry>
    <title>Nvidia-Container-Toolkit</title>
    <link href="http://example.com/2025/01/02/%E6%99%BA%E7%AE%97/Nvidia-Container-Toolkit/"/>
    <id>http://example.com/2025/01/02/%E6%99%BA%E7%AE%97/Nvidia-Container-Toolkit/</id>
    <published>2025-01-02T12:04:34.000Z</published>
    <updated>2025-01-09T02:38:18.163Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/02/%E6%99%BA%E7%AE%97/Nvidia-Container-Toolkit/2025-01-02-20-08-26.png">  </p><blockquote><p><a href="https://docs.nvidia.com/datacenter/cloud-native/">英伟达文档</a>  </p></blockquote><span id="more"></span><h1 id="NVIDIA-Container-Toolkit"><a href="#NVIDIA-Container-Toolkit" class="headerlink" title="NVIDIA Container Toolkit"></a>NVIDIA Container Toolkit</h1><p>NVIDIA Container Toolkit 是一套工具和库，简化在容器环境中使用 NVIDIA GPU 的过程。它允许用户在 Docker 或其他容器平台上运行 GPU 加速的应用程序，而无需手动配置复杂的驱动和环境。以下是其主要特点和功能：  </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装NVIDIA Container Toolkit之前需要先安装NVIDIA GPU 驱动程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置yum源</span></span><br><span class="line">sudo curl -s -L https://nvidia.github.io/libnvidia-container/stable/rpm/nvidia-container-toolkit.repo | sudo tee /etc/yum.repos.d/nvidia-container-toolkit.repo</span><br><span class="line"><span class="comment"># （可选）将存储库配置为使用实验性软件包</span></span><br><span class="line">sudo yum-config-manager --<span class="built_in">enable</span> nvidia-container-toolkit-experimental</span><br><span class="line"><span class="comment"># 安装 NVIDIA Container Toolkit 软件包</span></span><br><span class="line">sudo yum install -y nvidia-container-toolkit</span><br></pre></td></tr></table></figure><p>安装时可能会报OpenSSL错误，可以尝试在<a href="https://github.com/NVIDIA/nvidia-container-toolkit/releases">NVIDIA github</a>下载安装包进行安装</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>确保安装了容器引擎（Docker、Containerd、CRI-O、Podman），以及nvidia-container-toolkit  </p><h3 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置容器运行时</span></span><br><span class="line">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="line"><span class="comment"># 重新启动 Docker </span></span><br><span class="line"> systemctl restart docker</span><br></pre></td></tr></table></figure><p>当docker为无根模式（一种允许非特权用户（即普通用户，无需 root 权限）运行 Docker 容器的方式），使用以下配置方式  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置容器运行时</span></span><br><span class="line">nvidia-ctk runtime configure --runtime=docker --config=<span class="variable">$HOME</span>/.config/docker/daemon.json</span><br><span class="line"><span class="comment"># 重启无根 Docker</span></span><br><span class="line">systemctl --user restart docker</span><br><span class="line"><span class="comment"># 使用以下命令进行配置：/etc/nvidia-container-runtime/config.toml  sudo nvidia-ctk</span></span><br><span class="line">sudo nvidia-ctk config --<span class="built_in">set</span> nvidia-container-cli.no-cgroups --in-place</span><br></pre></td></tr></table></figure><h2 id="containerd（适用于-Kubernetes）"><a href="#containerd（适用于-Kubernetes）" class="headerlink" title="containerd（适用于 Kubernetes）"></a>containerd（适用于 Kubernetes）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 containerd</span></span><br><span class="line"><span class="comment"># 该命令将修改主机上的文件。该文件将更新，以便 containerd 可以使用 NVIDIA Container Runtime</span></span><br><span class="line">sudo nvidia-ctk /etc/containerd/config.toml</span><br><span class="line">sudo nvidia-ctk runtime configure --runtime=containerd</span><br><span class="line"><span class="comment"># 重新启动 containerd</span></span><br><span class="line">sudo systemctl restart containerd</span><br></pre></td></tr></table></figure><p>配置 containerd（用于 nerdctl）无需额外配置，在传统的 Docker 环境中，需要配置 Docker 使用 nvidia-container-runtime。但对于 containerd 和 nerdctl，无需额外配置，因为 nerdctl 可以直接调用 nvidia-container-toolkit 来启用 GPU 支持。 </p><h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用所有GPU</span></span><br><span class="line">sudo docker run --rm --runtime=nvidia --gpus all ubuntu nvidia-smi</span><br><span class="line"><span class="comment"># 使用特定的0,1 gpu</span></span><br><span class="line">sudo docker run --rm --runtime=nvidia --gpus <span class="string">&#x27;&quot;device=0,1&quot;&#x27;</span> ubuntu nvidia-smi</span><br><span class="line">sudo docker run --rm --runtime=nvidia --gpus 2 ubuntu nvidia-smi</span><br></pre></td></tr></table></figure><p>可以输出<code>nvidia-smi</code>结果证明安装完成</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/01/02/%E6%99%BA%E7%AE%97/Nvidia-Container-Toolkit/2025-01-02-20-08-26.png&quot;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.nvidia.com/datacenter/cloud-native/&quot;&gt;英伟达文档&lt;/a&gt;  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GPU" scheme="http://example.com/categories/GPU/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="GPU" scheme="http://example.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>智算中心网络架构</title>
    <link href="http://example.com/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/</id>
    <published>2024-12-19T07:24:39.000Z</published>
    <updated>2025-01-22T02:16:42.259Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习资料：<br>《百度智能云 智算中心网络架构白皮书》<br><a href="https://docs.nvidia.com/networking/display/mlnxofedv581121lts/opensm">NVIDIA MLNX_OFED</a><br><a href="https://network.nvidia.com/products/adapter-software/firmware-tools/">NVIDIA Firmware Tools (MFT)</a><br><a href="https://docs.redhat.com/zh-cn/documentation/red_hat_enterprise_linux/9/html-single/configuring_infiniband_and_rdma_networks/index#configuring-the-core-rdma-subsystem_configuring-infiniband-and-rdma-networks">RedHat 配置 InfiniBand 和 RDMA 网络</a><br><a href="https://docs.nvidia.com/networking/display/mftv4300/linux">NVIDIA MFT文档</a><br><a href="https://access.redhat.com/articles/7087953?extIdCarryOver=true&sc_cid=701f2000001Css5AAC">RedHat 安装配置OpenSM</a></p></blockquote><span id="more"></span><h2 id="大模型训练集群的网络要求"><a href="#大模型训练集群的网络要求" class="headerlink" title="大模型训练集群的网络要求"></a>大模型训练集群的网络要求</h2><p>大模型训练中的大规模参数对算力和显存都有较高的要求，为了缩短训练时间，需要通过分布式训练的方式，将模型参数和计算任务分配到多个计算节点上。<br>分布式训练系统的整体算力并不是简单的随着智算节点的增加而线性增加，而是存在加速比，且加速比小于1。存在加速比的原因是：在分布式训练中，计算节点之间需要频繁的进行通信，包括参数的同步、梯度的同步等，这些通信延迟会降低训练速度。<br>降低多机多卡间端到端通信时延的关键技术是 RDMA 技术。 RDMA 可以绕过操作系统内核， 让一台主机可以直接访问另外一台主机的内存。</p><h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><p>RDMA是一种新的直接内存访问技术，RDMA让计算机可以直接存取其他计算机的内存，而不需要经过处理器的处理。RDMA将数据从一个系统快速移动到远程系统的内存中，而不对操作系统造成任何影响。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-20-14-16-37.png"><br>实 现 RDMA 的 方 式 有 InfiniBand、 RoCEv1、 RoCEv2、 i WARP 四 种。 其 中 RoCEv1 技 术 当 前 已 经 被 淘 汰，<br>iWARP 使用较少。 当前 RDMA 技术主要采用的方案为 InfiniBand 和 RoCEv2 两种。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-20-14-22-38.png"></p><h3 id="InfiniBand"><a href="#InfiniBand" class="headerlink" title="InfiniBand"></a>InfiniBand</h3><p>InfiniBand（直译为“无限带宽”技术，缩写为IB）是一个用于高性能计算的计算机网络通信标准，它具有极高的吞吐量和极低的延迟，用于计算机与计算机之间的数据互连。InfiniBand也用作服务器与存储系统之间的直接或交换互连，以及存储系统之间的互连。<br>InfiniBand网络的关键组成包括Subnet Manager（ SM）、 InfiniBand 网卡、 InfiniBand交换机和InfiniBand连接线缆。  </p><h4 id="IB端口速率"><a href="#IB端口速率" class="headerlink" title="IB端口速率"></a>IB端口速率</h4><p><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-20-14-34-32.png"><br>IB（InfiniBand）端口速率对应不同的网卡、连接件和交换机。不同的IB网卡、线缆和交换机支持不同的数据传输速率</p><h4 id="IB网卡"><a href="#IB网卡" class="headerlink" title="IB网卡"></a>IB网卡</h4><p>IB网卡通常被称为HCA（Host Channel Adapter）。HCA是InfiniBand网络中的主机通道适配器，它连接主机系统（如服务器）和InfiniBand网络。HCA负责处理InfiniBand网络的数据传输，并提供高性能、低延迟的网络通信。HCA通常集成在服务器的主板或作为独立适配器安装。</p><h4 id="IB-Switch交换机"><a href="#IB-Switch交换机" class="headerlink" title="IB Switch交换机"></a>IB Switch交换机</h4><p>IB Switch（InfiniBand Switch）是InfiniBand网络中的核心设备，用于连接多个HCA（Host Channel Adapter）和设备，实现数据的高效传输。IB Switch具有高性能、低延迟和高度可扩展性等特点。</p><h4 id="连接件"><a href="#连接件" class="headerlink" title="连接件"></a>连接件</h4><p>InfiniBand 网络需要专用的线缆和光模块做交换机间的互联以及交换机和网卡的互联。<br>例如NDR交换机在Spine-Leaf层之间布线方式为双端使用800Gb光模块，Leaf到GPU服务器之间，Leaf交换机侧使用800Gb光模块，GPU服务器侧连接两个400Gb光模块。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-20-15-14-19.png">  </p><h4 id="Subnet-Manager"><a href="#Subnet-Manager" class="headerlink" title="Subnet Manager"></a>Subnet Manager</h4><p>InfiniBand 交换机上不运行任何路由协议。 整个网络的转发表是由集中式的子网管理器（ Subnet Manager， 简称 SM）<br>进行计算并统一下发的。SM 有 OpenSM（ 开源） 和 UFM（ 收费） 两种模式。  </p><ul><li><strong>部署</strong>：SM 通常部署在接入 InfiniBand 子网的一台服务器上， 可以把子网管理器理解为 InfiniBand 网络的控制器。一个子网内同时只能有一个 SM 工作， 如有多个设备配置成为 SM， 则只有一个 SM 能成为主 SM。 </li><li><strong>控制机制</strong>：SM 可以控制整个子网内所有的 InfiniBand 交换机和 InfiniBand 网卡， 控制信令也通过InfiniBand 网络带内下发和上传（ 统称 MAD， Management Datagram） 。 所有 InfiniBand 网卡端口和交换芯片都有一个子网内唯一的身份标识 LID（ Local ID） ， 由 SM 赋予。 SM 会计算每个交换芯片的路由表并下发。 SM 控制 InfiniBand 网卡， 并不需要 InfiniBand 网卡所在服务器的协助。  </li></ul><h5 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h5><p>OpenSM 是 InfiniBand 网络中的一个开源子网管理器（Subnet Manager），用于管理和配置 InfiniBand 子网。<br>需要使用 <strong>rdma-core、libibverbs-utils、infiniband-diags</strong>包支持，</p><ul><li>配置IPoIB<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MST工具查看网卡与以太网卡标识</span></span><br><span class="line">mst status -v   </span><br><span class="line">------------</span><br><span class="line">DEVICE_TYPE             MST                           PCI       RDMA            NET                       NUMA  </span><br><span class="line">ConnectX6(rev:0)        /dev/mst/mt4123_pciconf0      98:00.0   mlx5_4          net-ib0                   1 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> centos中配置/etc/sysconfig/network-scripts/ifcfg-&lt;interface_name&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置完成后重启网络服务或者启用接口</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">ifup ib0</span><br></pre></td></tr></table></figure></li><li>ibstat查看IB网卡状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CA &#x27;mlx5_0&#x27;  # 网卡名称</span><br><span class="line">    CA type: MT41170    # 网卡类型</span><br><span class="line">    Number of ports: 1 # 网卡端口数量</span><br><span class="line">    Firmware version: 16.28.1000 # 网卡固件版本</span><br><span class="line">    Hardware version: a0    # 网卡硬件版本</span><br><span class="line">    Node GUID: 0x00155d0300d1a9e0 # 网卡GUID</span><br><span class="line">    System image GUID: 0x00155d0300d1a9e0 # 网卡系统GUID</span><br><span class="line">    Port 1:</span><br><span class="line">        State: Active # 网卡端口状态</span><br><span class="line">        Physical state: LinkUp  # 网卡物理状态</span><br><span class="line">        Rate: 100  # 网卡速率</span><br><span class="line">        Base lid: 0 # 网卡基础LID</span><br><span class="line">        SM lid: 0</span><br><span class="line">        Port GUID: 0x00155d0300d1a9e1</span><br><span class="line">        Link layer: InfiniBand # 网卡链路层协议</span><br></pre></td></tr></table></figure></li><li>ibswitches获取当前子网的所有交换机的信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~]# ibswitches</span><br><span class="line">Switch: 0x946dae030016474e ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 25 lmc 0</span><br><span class="line">Switch: 0x946dae030016488e ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 8 lmc 0</span><br><span class="line">Switch: 0x946dae0300164ace ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 39 lmc 0</span><br><span class="line">Switch: 0x946dae030016476e ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 31 lmc 0</span><br><span class="line">Switch: 0x946dae03000ca39a ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 35 lmc 0</span><br><span class="line">Switch: 0x946dae0300095e9a ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 33 lmc 0</span><br><span class="line">Switch: 0x946dae0300095f1a ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 22 lmc 0</span><br><span class="line">Switch: 0x946dae030016482e ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 23 lmc 0</span><br><span class="line">Switch: 0x946dae0300095c9a ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 32 lmc 0</span><br><span class="line">Switch: 0x946dae0300095eda ports 41 &quot;Quantum Mellanox Technologies&quot; base port 0 lid 45 lmc 0</span><br></pre></td></tr></table></figure></li><li>ofed_info检测ofed驱动版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofed_info -s</span><br></pre></td></tr></table></figure></li><li>iblinkinfo 查看IB网卡连接信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Switch: 0x946dae030016494e Quantum Mellanox Technologies:</span><br><span class="line">          #lid  port  state  rate  link</span><br><span class="line">          26    1[  ] ==( 4X        53.125 Gbps Active/  LinkUp)==&gt;      40    1[  ] &quot;Quantum Mellanox Technologies&quot; ( )</span><br><span class="line">          26    2[  ] ==( 4X        53.125 Gbps Active/  LinkUp)==&gt;      40    2[  ] &quot;Quantum Mellanox Technologies&quot; ( )</span><br><span class="line">          26    3[  ] ==( 4X        53.125 Gbps Active/  LinkUp)==&gt;      24    1[  ] &quot;Quantum Mellanox Technologies&quot; ( )</span><br><span class="line">          26    4[  ] ==( 4X        53.125 Gbps Active/  LinkUp)==&gt;      24    2[  ] &quot;Quantum Mellanox Technologies&quot; ( )</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>sminfo获取当前节点的子网管理器的信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~]# sminfo </span><br><span class="line">sminfo: sm lid 1 sm guid 0x946dae0300146a70, activity count 117783369 priority 0 state 3 SMINFO_MASTER</span><br></pre></td></tr></table></figure></li><li>ibswitches获取当前子网的所有交换机的信息</li><li>ibhosts取当前子网的所有HCA的信息</li><li>ibnodes获取当前子网的所有交换机和HCA的信息</li><li>ibnetdiscover 获取 当前子网的所有交换机和HCA的信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vendid=0x2c9    # 网卡厂商ID</span><br><span class="line">devid=0xcf09    # 网卡设备ID</span><br><span class="line">sysimgguid=0x946dae03000c9c9a # 网卡系统GUID</span><br><span class="line">caguid=0x946dae03000c9ca2   # 网卡GUID</span><br><span class="line">Ca1 &quot;H-946dae03000c9ca2&quot;# &quot;Mellanox Technologies Aggregation Node&quot; </span><br><span class="line">[1](946dae03000c9ca2) &quot;S-946dae03000c9c9a&quot;[41]# lid 305 lmc 0 &quot;Quantum Mellanox Technologies&quot; lid 34 4xHDR  </span><br></pre></td></tr></table></figure></li></ul><h2 id="物理网络架构"><a href="#物理网络架构" class="headerlink" title="物理网络架构"></a>物理网络架构</h2><p>在智算场景中，当前比较好的实践是独立建一张高性能网络来承载智算业务， 满足大带宽， 低时延， 无损的需求。  </p><ul><li> 大带宽设计<br>智算服务器可以满配 8 张 GPU 卡， 并预留 8 个 PCIe 网卡插槽。 在多机组建 GPU 集群时， 两个 GPU 跨机互通的突发带宽有可能会大于 50Gbps。 因此， 一般会给每个 GPU 关联一个至少 100Gbps 的网络端口。 在这种场景下可以配置 4张 2<em>100Gbps 的网卡， 也可以配置 8 张 1</em>100Gbps 的网卡， 当然也可以配置 8 张单端口 200/400Gbps 的网卡。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-32-50.png"></li><li>无阻塞设计<br>无阻塞网络设计的关键是采用 Fat-Tree（ 胖树） 网络架构。 交换机下联和上联带宽采用 1： 1 无收敛设计， 即如果下联有64 个 100Gbps 的端口， 那么上联也有 64 个 100Gbps 的端口。</li><li>低时延设计 AI-Pool<br>8 个接入交换机为一组， 构成一个 AI-Pool。 以两层交换机组网架构为例， 这种网络架构能做到同 AI-Pool 的不同智算节点的 GPU 互访仅需一跳。在 AI-Pool 网络架构中， 不同智算节点间相同编号的网口需要连接到同一台交换机。 如智算节点 1 的 1 号 RDMA 网口，智算节点 2 的 1 号 RDMA 网口直到智算节点 P/2 的 1 号 RDMA 网口都连到 1 号交换机。</li></ul><p><strong>在智算节点内部</strong>， 上层通信库基于机内网络拓扑进行网络匹配， 让相同编号的 GPU 卡和相同编号的网口关联。 这样相同GPU 编号的两台智算节点间仅一跳就可互通。<br><strong>不同GPU编号的智算节点间</strong>， 借助NCCL通信库中的Rail Local技术， 可以充分利用主机内GPU间的NVSwitch的带宽，将多机间的跨卡号互通转换为跨机间的同GPU卡号的互通。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-39-24.png"><br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-39-37.png"></p><h3 id="智算网络可容纳的GPU卡的规模"><a href="#智算网络可容纳的GPU卡的规模" class="headerlink" title="智算网络可容纳的GPU卡的规模"></a>智算网络可容纳的GPU卡的规模</h3><p>网络可承载的 GPU 卡的规模和所采用交换机的端口密度、 网络架构相关。 网络的层次多， 承载的 GPU 卡的规模会变大，但转发的跳数和时延也会变大， 需要结合实际业务情况进行权衡。</p><h4 id="两层胖树架构"><a href="#两层胖树架构" class="headerlink" title="两层胖树架构"></a>两层胖树架构</h4><p>8 台接入交换机组成一个智算资源池 AI-Pool。 图中 P 代表单台交换机的端口数。 单台交换机最大可下联和上联的端口为P/2 个， 即单台交换机最多可以下联 P/2 台服务器和 P/2 台交换机。 两层胖树网络可以接入 P*P/2 张 GPU 卡。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-43-42.png">  </p><h4 id="三层胖树架构"><a href="#三层胖树架构" class="headerlink" title="三层胖树架构"></a>三层胖树架构</h4><p>三层网络架构中会新增汇聚交换机组和核心交换机组。 每个组里面的最大交换机数量为 P/2。 汇聚交换机组最大数量为 8，核心交换机组的最大数量为 P/2。 三层胖树网络可以接入 P*(P/2)*(P/2)=P*P*P/4 张 GPU 卡。<br>在三层胖树组网中， InfiniBand 的 40 端口的 200Gbps HDR 交换机能容纳的最多 GPU 数量是 16000。<br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-47-19.png"></p><h4 id="两层与三层胖树对比"><a href="#两层与三层胖树对比" class="headerlink" title="两层与三层胖树对比"></a>两层与三层胖树对比</h4><p><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-48-09.png"><br><img src="/2024/12/19/%E6%99%BA%E7%AE%97/%E6%99%BA%E7%AE%97%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/2024-12-25-14-48-27.png"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习资料：&lt;br&gt;《百度智能云 智算中心网络架构白皮书》&lt;br&gt;&lt;a href=&quot;https://docs.nvidia.com/networking/display/mlnxofedv581121lts/opensm&quot;&gt;NVIDIA MLNX_OFED&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://network.nvidia.com/products/adapter-software/firmware-tools/&quot;&gt;NVIDIA Firmware Tools (MFT)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://docs.redhat.com/zh-cn/documentation/red_hat_enterprise_linux/9/html-single/configuring_infiniband_and_rdma_networks/index#configuring-the-core-rdma-subsystem_configuring-infiniband-and-rdma-networks&quot;&gt;RedHat 配置 InfiniBand 和 RDMA 网络&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://docs.nvidia.com/networking/display/mftv4300/linux&quot;&gt;NVIDIA MFT文档&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://access.redhat.com/articles/7087953?extIdCarryOver=true&amp;sc_cid=701f2000001Css5AAC&quot;&gt;RedHat 安装配置OpenSM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="智算网络" scheme="http://example.com/categories/%E6%99%BA%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="智算网络" scheme="http://example.com/tags/%E6%99%BA%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>keepalived高可用</title>
    <link href="http://example.com/2024/12/05/keepalived/keepalived%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://example.com/2024/12/05/keepalived/keepalived%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2024-12-05T02:49:05.000Z</published>
    <updated>2024-12-31T05:41:57.828Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/12/05/JTH7A9gMoL5Vqby.png"></p><span id="more"></span><h1 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h1><p>Keepalived是一个开源的路由软件，主要用于提供高可用性（HA）解决方案，通过VRRP（Virtual Router Redundancy Protocol）协议实现负载均衡和故障转移。  </p><ol><li>高可用（HA）：Keepalived通过VRRP协议实现高可用性，允许一组路由器（或服务器）共享一个虚拟IP地址（VIP）。当主服务器（Master）故障时，备用服务器（Backup）可以自动接管这个VIP，确保服务不中断。  </li><li>VRRP：VRRP是一种网络协议，设计用于在多台路由器之间实现冗余。Keepalived利用VRRP来检测和管理服务器或路由器的健康状态。  </li><li>Keepalived提供健康检查机制，可以监控服务或服务器的健康状态。如果检测到故障，它可以自动进行故障转移，确保服务的高可用性。  </li><li>故障转移：当主服务器检测到故障或停止响应时，Keepalived会自动将VIP转移到备用服务器，从而实现无缝的服务转移。  </li><li>自定义脚本执行：支持在状态变更时执行自定义脚本，进行特定的操作，如通知管理员、启动或停止服务等。  </li></ol><h2 id="VRRP相关概念以及工作原理"><a href="#VRRP相关概念以及工作原理" class="headerlink" title="VRRP相关概念以及工作原理"></a>VRRP相关概念以及工作原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>虚拟路由器冗余协议（VRRP）</strong>：VRRP是一种网络协议，设计用于在多台路由器或服务器之间提供冗余，以提高网络的可靠性和可用性。<br><strong>虚拟IP（VIP）</strong>：VIP是一个共享的IP地址，被配置在VRRP组内的所有路由器或服务器上。客户端使用这个VIP来访问服务，而不直接访问具体的物理设备。<br><strong>VRRP组</strong>：一个VRRP组由一个或多个路由器组成，其中一个被选为主路由器（Master），其余为备用路由器（Backup）。<br><strong>Master路由器</strong>：在VRRP组中，优先级最高的路由器或被指定为Master，它负责处理流量和响应ARP请求。<br><strong>Backup路由器</strong>：如果Master路由器发生故障，Backup路由器中优先级最高的会接管成为新的Master。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>选举：<ul><li>VRRP通过选举机制确定Master。选举基于以下几个因素：</li><li>优先级：每个VRRP实例都有一个优先级，优先级高的路由器被选为Master。</li><li>IP地址：如果优先级相同，则选择拥有最高IP地址的路由器为Master。</li><li>VRRP通告（Advertisement）：Master路由器会定期发送VRRP通告信息（VRRP Advertisement），告知其他备用路由器自己是活跃的。  </li></ul></li><li>故障转移：<ul><li>当Master路由器停止发送VRRP通告（可能是由于故障或网络问题），Backup路由器会检测到此情况并启动选举过程：备用路由器等待一个预设的间隔（Master Down Interval）后，如果没有收到通告，则认为Master已下线。优先级最高的备用路由器将接管Master角色，接管VIP，并开始处理流量。</li></ul></li><li>VRRP报文：<ul><li>VRRP使用组播地址224.0.0.18发送VRRP报文，包括：<ul><li>VRRP Advertisement：由Master发送，用于告知状态。</li><li>VRRP Request：由新加入的或重启的路由器发送，用于请求当前的VRRP状态。</li></ul></li></ul></li><li>认证：<ul><li>VRRP支持简单的密码认证（如使用auth_type PASS），以防止非法节点加入VRRP组。</li></ul></li><li>负载均衡：<ul><li>VRRP本身不提供负载均衡，但可以与LVS（Linux Virtual Server）等负载均衡技术结合使用。</li></ul></li></ul><h2 id="keepalived工作模式"><a href="#keepalived工作模式" class="headerlink" title="keepalived工作模式"></a>keepalived工作模式</h2><ul><li>抢占模式：keepalived默认为抢占模式，在该模式下，如果一个优先级更高的备用节点（BACKUP）启动或者恢复，它会立即接管master</li><li>非抢占模式：在非抢占模式下，即使一个优先级更高的备用节点启动或恢复，它也不会主动接管Master角色，除非当前的Master节点出现故障。通过在VRRP实例配置中添加<code>nopreempt</code>选项来启用非抢占模式。</li></ul><h2 id="keepalived相关命令"><a href="#keepalived相关命令" class="headerlink" title="keepalived相关命令"></a>keepalived相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动停止重启服务</span></span><br><span class="line">systemctl start|stop|restart keepalived</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件检查</span></span><br><span class="line">keepalived -f /etc/keepalived/keepalived.conf -t</span><br></pre></td></tr></table></figure><p>启动keepalived后可以抓包查看多播信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ]tcpdump -i ens160 -nn|grep 224.0.0.18</span></span><br><span class="line">dropped privs to tcpdump</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on ens160, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">15:44:21.201129 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:22.201379 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:23.201802 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:24.201961 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:25.202133 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:26.202372 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:27.202754 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line">15:44:28.202836 IP 192.168.27.8 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 51, prio 100, authtype simple, intvl 1s, length 20</span><br><span class="line"><span class="meta">#</span><span class="bash"> 192.168.27.8 &gt; 224.0.0.18 源地址&gt;组播地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> VRRPv2, Advertisement 协议和类型</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vrid 51 VRRP实例ID为51</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> prio 100 节点优先级为100</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> authtype simple 使用简单的密码认证</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> intvl 1s 表示VRRP广告报文的发送间隔为1秒</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> length 20表示这个VRRP报文的长度为20字节</span></span><br></pre></td></tr></table></figure><h2 id="配置文件实例"><a href="#配置文件实例" class="headerlink" title="配置文件实例"></a>配置文件实例</h2><p>keepalived配置文件为/etc/keepalived/keepalived.conf  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># Keepalived配置文件示例</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    # 路由id：当前安装keepalived的节点主机标识符，确保全局唯一</span><br><span class="line">    router_id MASTER_1  # 对于备用节点，修改为BACKUP_1或其他唯一标识符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 业务应用检测脚本（可选）</span><br><span class="line">#vrrp_script check_component &#123;</span><br><span class="line">#    # 业务应用检测脚本路径</span><br><span class="line">#    script &quot;/etc/keepalived/check_component.sh&quot;</span><br><span class="line">#    # 每隔两秒运行一次脚本</span><br><span class="line">#    interval 2</span><br><span class="line">#    # 脚本运行的超时时间</span><br><span class="line">#    timeout 5</span><br><span class="line">#    # 配置几次检测失败才认为服务异常</span><br><span class="line">#    fall 2</span><br><span class="line">#    # 优先级变化幅度，如果script中的指令执行失败，那么相应的vrrp_instance的优先级会减少10个点。</span><br><span class="line">#    weight -10</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 表示状态是MASTER主机还是备用机BACKUP</span><br><span class="line">    state MASTER  # 对于备用节点，修改为BACKUP,主要还是依靠priority来确定哪一个是master</span><br><span class="line">    # 该实例绑定的网卡,如：eth0</span><br><span class="line">    interface ens160</span><br><span class="line">    # 保证主备节点一致即可</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 权重[1-255]，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选</span><br><span class="line">    priority 100  # 对于备用节点，设置一个较低的优先级，如70</span><br><span class="line">    # 主备之间同步检查时间间隔，单位秒</span><br><span class="line">    advert_int 1</span><br><span class="line">    # 认证权限密码，防止非法节点进入</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass password  # 替换为实际的密码,支持最多8个字符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 如果需要非抢占模式，可以添加以下行,默认使用抢占模式</span><br><span class="line">    #</span><br><span class="line">    # nopreempt</span><br><span class="line"></span><br><span class="line">    # 业务应用检测脚本在本VRRP实例中使用</span><br><span class="line">#    track_script &#123;</span><br><span class="line">#        check_component</span><br><span class="line">#    &#125;</span><br><span class="line"></span><br><span class="line">    # 虚拟出来的ip，可以有多个（vip）</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        # 注意：主备两台的vip都是一样的，绑定到同一个vip,设置别名</span><br><span class="line">        192.168.27.100/24 dev ens160 label ens160:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果需要多个VRRP实例，可以添加更多vrrp_instance块</span><br><span class="line"># vrrp_instance VI_2 &#123;</span><br><span class="line">#     ...</span><br><span class="line"># &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/12/05/JTH7A9gMoL5Vqby.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="keepalived" scheme="http://example.com/categories/keepalived/"/>
    
    
    <category term="keepalived高可用" scheme="http://example.com/tags/keepalived%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>8-nginx负载均衡</title>
    <link href="http://example.com/2024/11/27/Nginx/8-nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2024/11/27/Nginx/8-nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2024-11-27T03:26:19.000Z</published>
    <updated>2024-12-31T06:04:12.203Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="查看与启用stream模块"><a href="#查看与启用stream模块" class="headerlink" title="查看与启用stream模块"></a>查看与启用stream模块</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V 2&gt;&amp;1 | grep -- &#x27;--with-stream&#x27;</span><br></pre></td></tr></table></figure><p>-with-stream=dynamic，状态为已经安装但是没有默认加载，需要手动进行加载，</p><h1 id="服务器组"><a href="#服务器组" class="headerlink" title="服务器组"></a>服务器组</h1><p>upstream设置后端服务器组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream test_team&#123;    #设置服务器组名为test_team</span><br><span class="line">    #ip_hash;      #，会话保持，请求按照IP的hash结果分配，每个访客固定访问一个后端服务器，不能与server中的weigth一同使用，并且必须是最前端的服务器，这样才能获取到客户端的IP</span><br><span class="line"></span><br><span class="line">    #hash $remote_addr consistent;</span><br><span class="line">    #根据指定的键进行哈希，更加灵活，可以使用任意变量作为哈希键，适用于需要更复杂哈希策略的场景。</span><br><span class="line">    #可以通过 consistent 关键字启用一致性哈希，减少服务器增减时的哈希重新分布。</span><br><span class="line"></span><br><span class="line">    server 192.168.27.11;</span><br><span class="line">    server 192.168.27.12 weight=5;  # weight=5权重为5，默认为1，越大越优先用于处理请求</span><br><span class="line">    server 192.168.27.13 fail_timeout=10s  max_fails=3; #10秒内连续三次失败，则在随后的10秒内认为服务器是无效的</span><br><span class="line">    server 192.168.27.14 backup;  #备用服务器，只有在正常服务器处于down或者busy时才会被使用</span><br><span class="line">    server 192.168.27.15 down;   #标记为永久down状态，通常与ip_hash配合使用</span><br><span class="line">    #last_conn  #把请求分派给连接数最少的服务器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="例一-一般轮询规则"><a href="#例一-一般轮询规则" class="headerlink" title="例一:一般轮询规则"></a>例一:一般轮询规则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">    server 192.168.27.11:80;</span><br><span class="line">    server 192.168.27.12:80;</span><br><span class="line">    server 192.168.27.13:80;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80；</span><br><span class="line">    server_name www.test.demo;</span><br><span class="line">    index index.html;</span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_set_header HOST $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例二：加权轮询规则"><a href="#例二：加权轮询规则" class="headerlink" title="例二：加权轮询规则"></a>例二：加权轮询规则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">    server 192.168.27.11:80 weight=3;</span><br><span class="line">    server 192.168.27.12:80 weight=2;</span><br><span class="line">    server 192.168.27.13:80 weight=1;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80；</span><br><span class="line">    server_name www.test.demo;</span><br><span class="line">    index index.html;</span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_set_header HOST $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例三-对特定资源实现负载均衡"><a href="#例三-对特定资源实现负载均衡" class="headerlink" title="例三:对特定资源实现负载均衡"></a>例三:对特定资源实现负载均衡</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">upstream file&#123;</span><br><span class="line">    server 192.168.27.11:80;</span><br><span class="line">    server 192.168.27.12:80;</span><br><span class="line">    server 192.168.27.13:80;</span><br><span class="line">&#125;</span><br><span class="line">upstream video&#123;</span><br><span class="line">    server 192.168.27.11:80;</span><br><span class="line">    server 192.168.27.12:80;</span><br><span class="line">    server 192.168.27.13:80;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80；</span><br><span class="line">    server_name www.test.demo;</span><br><span class="line">    index index.html;</span><br><span class="line">    location /file/&#123;</span><br><span class="line">        proxy_pass http://file;</span><br><span class="line">    &#125;</span><br><span class="line">    location /video/&#123;</span><br><span class="line">        proxy_pass http://video;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例四：带有URL重写的负载均衡"><a href="#例四：带有URL重写的负载均衡" class="headerlink" title="例四：带有URL重写的负载均衡"></a>例四：带有URL重写的负载均衡</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">    server 192.168.27.11:80 weight=3;</span><br><span class="line">    server 192.168.27.12:80 weight=2;</span><br><span class="line">    server 192.168.27.13:80 weight=1;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80；</span><br><span class="line">    server_name www.test.demo;</span><br><span class="line">    index index.html;</span><br><span class="line">    location /backend/&#123;</span><br><span class="line">        rewrite ^(.*) XXX last;</span><br><span class="line">    &#125;</span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_set_header HOST $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例五：哈希"><a href="#例五：哈希" class="headerlink" title="例五：哈希"></a>例五：哈希</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_servers &#123;</span><br><span class="line">    hash $remote_addr consistent;</span><br><span class="line">    server 192.168.1.101;</span><br><span class="line">    server 192.168.1.102;</span><br><span class="line">    server 192.168.1.103;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx负载均衡" scheme="http://example.com/tags/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>7-nginx代理服务</title>
    <link href="http://example.com/2024/11/26/Nginx/7-nginx%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/11/26/Nginx/7-nginx%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-11-26T06:21:56.000Z</published>
    <updated>2024-12-18T15:45:24.838Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="Nginx-代理服务"><a href="#Nginx-代理服务" class="headerlink" title="Nginx 代理服务"></a>Nginx 代理服务</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>定义： 正向代理是指客户端通过代理服务器访问目标服务器。客户端配置了代理服务器的地址和端口，所有请求都先发送到代理服务器，再由代理服务器转发到目标服务器，最后将目标服务器的响应返回给客户端。</p><p>应用场景：</p><ul><li>内网用户通过代理服务器访问外网资源。</li><li>控制和监控内网用户对外网的访问。</li><li>提高访问速度，通过缓存机制减少重复请求。</li></ul><p>工作流程：</p><ol><li>客户端配置代理服务器： 客户端配置代理服务器的地址和端口。</li><li>客户端发送请求： 客户端将请求发送到代理服务器。</li><li>代理服务器转发请求： 代理服务器根据请求中的目标地址，将请求转发到目标服务器。</li><li>目标服务器响应： 目标服务器处理请求并返回响应。</li><li>代理服务器返回响应： 代理服务器将目标服务器的响应返回给客户端</li></ol><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    resolver 8.8.8.8;          # 指定 DNS 服务器 IP 地址，默认使用 53 端口，是必须的指令</span><br><span class="line">    resolver_timeout 3s;       # DNS 服务器域名解析超时时间</span><br><span class="line">    listen 82;                 # 监听 82 端口</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://$http_host$request_uri;  # 设置代理服务器协议和地址</span><br><span class="line">        #$http_host：这是客户端请求中的 Host 头字段，表示目标服务器的主机名。</span><br><span class="line">        #$request_uri：这是客户端请求中的 URI（统一资源标识符），表示请求的具体路径和查询参数。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端访问流程"><a href="#客户端访问流程" class="headerlink" title="客户端访问流程"></a>客户端访问流程</h3><p>客户端配置了 http_proxy 和 https_proxy 环境变量，指定了代理服务器的地址和端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://proxy.com:82/</span><br><span class="line">export https_proxy=http://proxy.com:82/</span><br></pre></td></tr></table></figure><p>客户端发送的请求可能是</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><ul><li>客户端配置：客户端通过 http_proxy 和 https_proxy 环境变量将请求发送到 <a href="http://proxy.com:82。">http://proxy.com:82。</a></li><li>DNS 解析：客户端自动解析 proxy.com 的域名，将其转换为代理服务器的 IP 地址 192.168.1.100。</li><li>代理服务器监听：代理服务器在指定的端口上监听，接收并处理客户端的请求。</li><li>代理服务器解析目标地址：代理服务器使用 resolver 指令中指定的 DNS 服务器将目标域名解析为 目标IP 地址。</li><li>代理服务器转发请求：代理服务器将请求转发到目标服务器。</li><li>目标服务器响应：目标服务器处理请求并返回响应。</li><li>代理服务器返回响应：代理服务器将目标服务器的响应返回给客户端。</li></ul><h3 id="Linux-中配置代理服务器"><a href="#Linux-中配置代理服务器" class="headerlink" title="Linux 中配置代理服务器"></a>Linux 中配置代理服务器</h3><p>在 Linux 中，可以通过设置环境变量来配置系统级别的代理服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://proxy.com:82/</span><br><span class="line">export https_proxy=http://proxy.com:82/</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><strong>定义</strong>： 反向代理是指客户端访问代理服务器，代理服务器再将请求转发到后端的真实服务器。客户端不知道后端服务器的存在，只与代理服务器交互。</p><p><strong>应用场景</strong>：</p><ul><li>负载均衡：将请求分发到多个后端服务器，提高系统性能。</li><li>安全性：隐藏后端服务器的真实地址，增加安全性。</li><li>缓存：通过缓存机制减少后端服务器的负载。</li></ul><p><strong>工作流程</strong>：</p><ol><li>客户端发送请求： 客户端将请求发送到代理服务器。</li><li>代理服务器转发请求： 代理服务器根据配置将请求转发到后端服务器。</li><li>后端服务器响应： 后端服务器处理请求并返回响应。</li><li>代理服务器返回响应： 代理服务器将后端服务器的响应返回给客户端。</li></ol><h3 id="proxy-pass-指令"><a href="#proxy-pass-指令" class="headerlink" title="proxy_pass 指令"></a><code>proxy_pass</code> 指令</h3><p><code>proxy_pass</code> 指令用于设置被代理的服务器的地址，可以使主机名、IP 加端口，也可以是一组后端服务器。</p><h4 id="示例-1-单个后端服务器"><a href="#示例-1-单个后端服务器" class="headerlink" title="示例 1: 单个后端服务器"></a>示例 1: 单个后端服务器</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://www.demo.de/uri;  <span class="comment"># 设置代理服务器协议和地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-2-使用一组后端服务器"><a href="#示例-2-使用一组后端服务器" class="headerlink" title="示例 2: 使用一组后端服务器"></a>示例 2: 使用一组后端服务器</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> proxy_team &#123;</span><br><span class="line">    <span class="attribute">server</span> http://192.168.27.10/uri;  <span class="comment"># 后端服务器地址</span></span><br><span class="line">    <span class="attribute">server</span> http://192.168.27.11/uri;  <span class="comment"># 后端服务器地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> proxy_team;  <span class="comment"># 使用 upstream 定义的后端服务器组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-3-不同的-upstream-配置方式"><a href="#示例-3-不同的-upstream-配置方式" class="headerlink" title="示例 3: 不同的 upstream 配置方式"></a>示例 3: 不同的 <code>upstream</code> 配置方式</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> proxy_team &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.27.10</span>/uri;  <span class="comment"># 后端服务器地址，不加 http://</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.27.11</span>/uri;  <span class="comment"># 后端服务器地址，不加 http://</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://proxy_team;  <span class="comment"># 使用 upstream 定义的后端服务器组，需要加 http://</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proxy-pass-URL-参数中的-URI"><a href="#proxy-pass-URL-参数中的-URI" class="headerlink" title="proxy_pass URL 参数中的 URI"></a><code>proxy_pass</code> URL 参数中的 URI</h3><ul><li>如果 <code>proxy_pass</code> URL 参数中不带 URI，则不会改变原地址的 URI。</li><li>如果 <code>proxy_pass</code> URL 参数中带有 URI，则会改变源地址的 URI。</li></ul><h4 id="示例-4-不带-URI"><a href="#示例-4-不带-URI" class="headerlink" title="示例 4: 不带 URI"></a>示例 4: 不带 URI</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /demo/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.27.12;  <span class="comment"># 不带 URI，保留原始 URI</span></span><br><span class="line">        <span class="comment"># 当访问 www.demo.de/demo 时，会转向为 http://192.168.27.12/demo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-5-带-URI"><a href="#示例-5-带-URI" class="headerlink" title="示例 5: 带 URI"></a>示例 5: 带 URI</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /demo/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.27.12/test;  <span class="comment"># 带 URI，替换原始 URI</span></span><br><span class="line">        <span class="comment"># 当访问 www.demo.de/demo 时，会转向为 http://192.168.27.12/test</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他常用配置"><a href="#其他常用配置" class="headerlink" title="其他常用配置"></a>其他常用配置</h3><h4 id="proxy-set-header-指令"><a href="#proxy-set-header-指令" class="headerlink" title="proxy_set_header 指令"></a><code>proxy_set_header</code> 指令</h4><p>用于设置代理请求头。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;  <span class="comment"># 设置 Host 头为客户端请求的 Host 头</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;  <span class="comment"># 设置 X-Real-IP 头为客户端的真实 IP 地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;  <span class="comment"># 设置 X-Forwarded-For 头</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto $scheme;  <span class="comment"># 设置 X-Forwarded-Proto 头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="proxy-connect-timeout-指令"><a href="#proxy-connect-timeout-指令" class="headerlink" title="proxy_connect_timeout 指令"></a><code>proxy_connect_timeout</code> 指令</h4><p>设置与后端服务器建立连接的超时时间。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">60s</span>;  <span class="comment"># 设置连接超时时间为 60 秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="proxy-read-timeout-指令"><a href="#proxy-read-timeout-指令" class="headerlink" title="proxy_read_timeout 指令"></a><code>proxy_read_timeout</code> 指令</h4><p>设置从后端服务器读取响应的超时时间。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">60s</span>;  <span class="comment"># 设置读取超时时间为 60 秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="proxy-send-timeout-指令"><a href="#proxy-send-timeout-指令" class="headerlink" title="proxy_send_timeout 指令"></a><code>proxy_send_timeout</code> 指令</h4><p>设置向后端服务器发送请求的超时时间。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.demo.de;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">60s</span>;  <span class="comment"># 设置发送超时时间为 60 秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理配置示例"><a href="#反向代理配置示例" class="headerlink" title="反向代理配置示例"></a>反向代理配置示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"># 定义用户和工作进程数</span><br><span class="line">user nginx;  # 指定 Nginx 工作进程运行的用户</span><br><span class="line">worker_processes auto;  # 自动设置工作进程数，通常与 CPU 核心数相同</span><br><span class="line"></span><br><span class="line"># 错误日志配置</span><br><span class="line">error_log /var/log/nginx/error.log warn;  # 设置错误日志文件路径和日志级别</span><br><span class="line">pid /var/run/nginx.pid;  # 设置 Nginx 主进程 ID 文件路径</span><br><span class="line"></span><br><span class="line"># 事件处理配置</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;  # 每个工作进程可以同时处理的最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP 配置块</span><br><span class="line">http &#123;</span><br><span class="line">    # 包含 MIME 类型配置文件</span><br><span class="line">    include /etc/nginx/mime.types;  # 包含 MIME 类型配置文件</span><br><span class="line">    default_type application/octet-stream;  # 默认的 MIME 类型</span><br><span class="line"></span><br><span class="line">    # 日志格式配置</span><br><span class="line">    log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                    &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                    &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;  # 定义日志格式</span><br><span class="line"></span><br><span class="line">    # 访问日志配置</span><br><span class="line">    access_log /var/log/nginx/access.log main;  # 设置访问日志文件路径和格式</span><br><span class="line"></span><br><span class="line">    # 发送文件配置</span><br><span class="line">    sendfile on;  # 启用 sendfile 系统调用提高性能</span><br><span class="line">    tcp_nopush on;  # 启用 TCP_NOPUSH 选项</span><br><span class="line">    tcp_nodelay on;  # 启用 TCP_NODELAY 选项</span><br><span class="line">    keepalive_timeout 65;  # 设置保持连接的超时时间</span><br><span class="line">    types_hash_max_size 2048;  # 设置 MIME 类型哈希表的最大大小</span><br><span class="line"></span><br><span class="line">    # 包含额外的配置文件</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;  # 包含额外的配置文件</span><br><span class="line"></span><br><span class="line">    # 定义上游服务器组</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 192.0.2.1:80;  # 目标服务器1</span><br><span class="line">        server 192.0.2.2:80;  # 目标服务器2</span><br><span class="line">        # 可以添加更多的服务器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 配置代理服务器</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 82;  # 监听 82 端口</span><br><span class="line">        server_name proxy.com;  # 代理服务器域名</span><br><span class="line"></span><br><span class="line">        # DNS 解析配置</span><br><span class="line">        resolver 8.8.8.8 valid=300s;  # 使用 Google 的公共 DNS 服务器进行域名解析，缓存时间为 300 秒</span><br><span class="line">        resolver_timeout 5s;  # 设置 DNS 解析超时时间为 5 秒</span><br><span class="line"></span><br><span class="line">        # 日志配置</span><br><span class="line">        access_log /var/log/nginx/proxy_access.log main;  # 设置代理服务器的访问日志文件路径和格式</span><br><span class="line">        error_log /var/log/nginx/proxy_error.log warn;  # 设置代理服务器的错误日志文件路径和日志级别</span><br><span class="line"></span><br><span class="line">        # 默认位置配置</span><br><span class="line">        location / &#123;</span><br><span class="line">            # 将请求转发到上游服务器组</span><br><span class="line">            proxy_pass http://backend;  # 将请求转发到上游服务器组 backend</span><br><span class="line"></span><br><span class="line">            # 设置代理头信息</span><br><span class="line">            proxy_set_header Host $host;  # 设置 Host 头为客户端请求的 Host 头</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;  # 设置 X-Real-IP 头为客户端的真实 IP 地址</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # 设置 X-Forwarded-For 头</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;  # 设置 X-Forwarded-Proto 头</span><br><span class="line"></span><br><span class="line">            # 设置连接超时时间</span><br><span class="line">            proxy_connect_timeout 60s;  # 设置连接超时时间为 60 秒</span><br><span class="line">            proxy_read_timeout 60s;  # 设置读取超时时间为 60 秒</span><br><span class="line">            proxy_send_timeout 60s;  # 设置发送超时时间为 60 秒</span><br><span class="line"></span><br><span class="line">            # 设置缓冲区大小</span><br><span class="line">            proxy_buffer_size 128k;  # 设置代理缓冲区大小</span><br><span class="line">            proxy_buffers 4 256k;  # 设置代理缓冲区数量和大小</span><br><span class="line">            proxy_busy_buffers_size 256k;  # 设置忙碌缓冲区大小</span><br><span class="line">            proxy_temp_file_write_size 256k;  # 设置临时文件写入大小</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 错误页面配置</span><br><span class="line">        error_page 500 502 503 504 /50x.html;  # 定义错误页面</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root /usr/share/nginx/html;  # 定义错误页面的具体路径</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx代理服务" scheme="http://example.com/tags/nginx%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>6-nginx rewrite</title>
    <link href="http://example.com/2024/11/25/Nginx/6-nginx%E4%B9%8Brewrite/"/>
    <id>http://example.com/2024/11/25/Nginx/6-nginx%E4%B9%8Brewrite/</id>
    <published>2024-11-25T07:44:33.000Z</published>
    <updated>2024-12-18T15:45:08.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="Nginx-Rewrite"><a href="#Nginx-Rewrite" class="headerlink" title="Nginx Rewrite"></a>Nginx Rewrite</h1><ol><li><p>rewrite 指令的位置<br>rewrite 指令确实可以放置在 server、location 或 if 块中。</p></li><li><p>rewrite 匹配的范围<br>rewrite 指令只对域名后的路径部分（即 URL 中的路径部分）起作用，不包括查询参数（query string）和片段标识符（fragment identifier）。具体来说：</p></li></ol><p>路径部分：例如 <a href="http://192.168.27.11:9090/targets">http://192.168.27.11:9090/targets</a> 中的 /targets。<br>查询参数：例如 <a href="http://192.168.27.11:9090/targets?search=pool-prometheus">http://192.168.27.11:9090/targets?search=pool-prometheus</a> 中的 ?search=pool-prometheus。<br>片段标识符：例如 <a href="http://192.168.27.11:9090/targets#pool-prometheus">http://192.168.27.11:9090/targets#pool-prometheus</a> 中的 #pool-prometheus。</p><ol start="3"><li>示例  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location /old &#123;</span><br><span class="line">        rewrite ^/old/(.*)$ /new/$1 permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 访问 http://example.com/old/path?param=value#fragment</span><br><span class="line"># 会被重定向到 http://example.com/new/path?param=value#fragment</span><br></pre></td></tr></table></figure></li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span> regex replacement [flag];</span><br></pre></td></tr></table></figure><ul><li><strong>regex</strong>: 正则表达式，用于匹配 URL。</li><li><strong>replacement</strong>: 重写后的 URL，可以包含 Nginx 内置变量，如 <code>$host</code> 表示请求的主机名。</li><li><strong>flag</strong>: 标记，控制重写行为。</li></ul><h3 id="常见标记"><a href="#常见标记" class="headerlink" title="常见标记"></a>常见标记</h3><ul><li><strong>last</strong>: 终止当前 <code>location</code> 块中的处理，并将重写后的 URI 作为新的 URI 进行处理。通常用于内部重定向。</li><li><strong>break</strong>: 将重写后的 URI 在当前 <code>location</code> 块中继续处理，不会将新的 URI 转移到其他 <code>location</code> 块。</li><li><strong>redirect</strong>: 返回 302 临时重定向，浏览器地址栏会显示跳转后的 URL。下次访问同一个 URL 时，浏览器会重新发起请求，而不是直接跳转到上次重定向的 URL。</li><li><strong>permanent</strong>: 返回 301 永久重定向，浏览器地址栏会显示跳转后的 URL。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-临时重定向"><a href="#1-临时重定向" class="headerlink" title="1. 临时重定向"></a>1. 临时重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> old_web.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.new_web.com/ <span class="literal">redirect</span>;  <span class="comment"># 使用 302 临时重定向，浏览器地址栏会显示跳转后的 URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-永久重定向"><a href="#2-永久重定向" class="headerlink" title="2. 永久重定向"></a>2. 永久重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> old_web.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.new_web.com/ <span class="literal">permanent</span>;  <span class="comment"># 使用 301 永久重定向，浏览器地址栏会显示跳转后的 URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-内部重定向"><a href="#3-内部重定向" class="headerlink" title="3. 内部重定向"></a>3. 内部重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">location</span> /old &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/old/(.*)$</span> /new/<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># 使用 last 标志，终止当前 location 块中的处理，并将重写后的 URI 作为新的 URI 进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /new &#123;</span><br><span class="line">        <span class="comment"># 处理新路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-条件重定向"><a href="#4-条件重定向" class="headerlink" title="4. 条件重定向"></a>4. 条件重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> test1.com test2.com;</span><br><span class="line">    <span class="attribute">if</span> ($host <span class="regexp">~ test)</span> &#123;  <span class="comment"># 如果请求的主机名包含 &quot;test&quot;</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> http://www.test3.com/<span class="variable">$1</span> <span class="literal">permanent</span>;  <span class="comment"># 使用 301 永久重定向到新的 URL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h2><p><code>if</code> 语句用于在 <code>server</code> 或 <code>location</code> 块中进行条件判断。常见的条件包括：</p><ul><li><strong>变量名</strong>: 变量的值为 <code>0</code> 或空字符串时，条件为 <code>false</code>。</li><li><strong>变量与字符串相等</strong>: 使用 <code>=</code> 和 <code>!=</code>，判断变量和字符串是否相等。</li><li><strong>变量与字符串匹配</strong>: 使用 <code>~</code>（区分大小写）和 <code>~*</code>（不区分大小写），判断变量值是否包含正则匹配内容。</li><li><strong>文件存在</strong>: 使用 <code>-f</code> 和 <code>!-f</code>，判断文件是否存在。</li><li><strong>目录存在</strong>: 使用 <code>-d</code> 和 <code>!-d</code>，判断目录是否存在。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> ($http_user_agent <span class="regexp">~* &quot;MSIE&quot;)</span> &#123;  <span class="comment"># 如果 User-Agent 包含 &quot;MSIE&quot;（不区分大小写）</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /ie.html <span class="literal">break</span>;  <span class="comment"># 使用 break 标志，重定向到 /ie.html 并停止进一步处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (-f $request_filename) &#123;  <span class="comment"># 如果请求的文件存在</span></span><br><span class="line">        break;  <span class="comment"># 停止进一步处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (-d $request_filename) &#123;  <span class="comment"># 如果请求的目录存在</span></span><br><span class="line">        break;  <span class="comment"># 停止进一步处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> $uri $uri/ /index.html;  <span class="comment"># 尝试匹配文件、目录或默认到 index.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a><code>break</code> 语句</h2><p><code>break</code> 语句用于中断当前作用域中的其他 Nginx 配置，使得 <code>break</code> 之前的指令生效，之后的指令不生效。可以在 <code>server</code>、<code>location</code> 或 <code>if</code> 中使用。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">if</span> ($arg_test = <span class="string">&quot;yes&quot;</span>) &#123;  <span class="comment"># 如果请求参数 test 等于 &quot;yes&quot;</span></span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/test$</span> /test2 <span class="literal">break</span>;  <span class="comment"># 使用 break 标志，重定向到 /test2 并停止进一步处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 以下指令不会被执行</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;  <span class="comment"># 这条指令不会被执行，因为前面的 break 已经停止了进一步处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a><code>return</code> 语句</h2><p><code>return</code> 语句用于直接向客户端返回响应状态码。可以在 <code>server</code>、<code>location</code> 或 <code>if</code> 中使用。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /maintenance &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">503</span>;  <span class="comment"># 直接返回 503 Service Unavailable 状态码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /redirect &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> http://www.newsite.com/;  <span class="comment"># 直接返回 301 永久重定向到新的 URL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-语句"><a href="#set-语句" class="headerlink" title="set 语句"></a><code>set</code> 语句</h2><p><code>set</code> 语句用于设置一个新的变量。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">set</span> $test_name <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment"># 设置一个名为 $test_name 的变量，值为 &quot;Hello, World!&quot;</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> $test_name;  <span class="comment"># 返回 200 OK 状态码，并返回变量 $test_name 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewrite-log-语句"><a href="#rewrite-log-语句" class="headerlink" title="rewrite_log 语句"></a><code>rewrite_log</code> 语句</h2><p><code>rewrite_log</code> 语句用于开启或关闭 <code>rewrite</code> 日志输出功能。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">rewrite_log</span> <span class="literal">on</span>;  <span class="comment"># 开启 rewrite 日志记录</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/old/(.*)$</span> /new/<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># 使用 last 标志，终止当前 location 块中的处理，并将重写后的 URI 作为新的 URI 进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述配置和示例，你可以更好地理解和使用 Nginx 的 <code>rewrite</code> 模块。<code>rewrite</code> 模块在处理 URL 重写和重定向方面非常强大，可以帮助你优化网站的访问体验和 SEO 效果。希望这些内容对你有所帮助！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="rewrite" scheme="http://example.com/tags/rewrite/"/>
    
  </entry>
  
  <entry>
    <title>5-nginx Gzip</title>
    <link href="http://example.com/2024/11/24/Nginx/5-nginx%E7%9A%84Gzip%E5%8E%8B%E7%BC%A9/"/>
    <id>http://example.com/2024/11/24/Nginx/5-nginx%E7%9A%84Gzip%E5%8E%8B%E7%BC%A9/</id>
    <published>2024-11-24T06:44:25.000Z</published>
    <updated>2024-12-18T15:44:59.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="Nginx-Gzip-压缩"><a href="#Nginx-Gzip-压缩" class="headerlink" title="Nginx Gzip 压缩"></a>Nginx Gzip 压缩</h1><p>Gzip 压缩通过在线实时压缩响应数据，显著减少传输的数据量，从而节省带宽并提高页面加载速度。虽然这会消耗一定的 CPU 资源，但总体上可以提升用户体验。Nginx 提供了 <code>ngx_http_gzip_module</code> 模块来实现这一功能。</p><h2 id="开启或关闭-Gzip"><a href="#开启或关闭-Gzip" class="headerlink" title="开启或关闭 Gzip"></a>开启或关闭 Gzip</h2><p>使用 <code>gzip</code> 指令来开启或关闭 Gzip 压缩。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><h2 id="设置-Gzip-缓冲区大小"><a href="#设置-Gzip-缓冲区大小" class="headerlink" title="设置 Gzip 缓冲区大小"></a>设置 Gzip 缓冲区大小</h2><p><code>gzip_buffers</code> 指令设置用于 Gzip 压缩的缓存空间大小。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br></pre></td></tr></table></figure><ul><li><code>NUMBER</code>: 空间数</li><li><code>SIZE</code>: 每个缓存空间的大小</li></ul><h2 id="设置-Gzip-压缩级别"><a href="#设置-Gzip-压缩级别" class="headerlink" title="设置 Gzip 压缩级别"></a>设置 Gzip 压缩级别</h2><p><code>gzip_comp_level</code> 指令设置压缩级别，范围为 1 到 9，数值越大压缩比越高，但压缩时间也越长。通常建议设置为 5。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="针对特定客户端禁用-Gzip"><a href="#针对特定客户端禁用-Gzip" class="headerlink" title="针对特定客户端禁用 Gzip"></a>针对特定客户端禁用 Gzip</h2><p><code>gzip_disable</code> 指令可以根据客户端的 User-Agent 字符串选择性地禁用 Gzip 压缩。支持正则表达式。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_disable</span> <span class="string">&quot;MSIE [1-6]\.&quot;</span>;</span><br></pre></td></tr></table></figure><p>例如，低版本的 IE 浏览器不支持 Gzip 压缩，可以禁用。</p><h2 id="设置最小压缩数据大小"><a href="#设置最小压缩数据大小" class="headerlink" title="设置最小压缩数据大小"></a>设置最小压缩数据大小</h2><p><code>gzip_min_length</code> 指令设置压缩数据的最小大小，防止对太小的数据进行压缩导致数据变大。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br></pre></td></tr></table></figure><h2 id="指定-MIME-类型进行压缩"><a href="#指定-MIME-类型进行压缩" class="headerlink" title="指定 MIME 类型进行压缩"></a>指定 MIME 类型进行压缩</h2><p><code>gzip_types</code> 指令指定哪些 MIME 类型的数据需要进行压缩。默认情况下，只有 <code>text/html</code> 会被压缩。可以设置为 <code>*</code> 来压缩所有类型的数据。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_types</span> text/plain application/x-javascript text/css text/html application/xml application/json;</span><br></pre></td></tr></table></figure><h2 id="发送-Vary-头"><a href="#发送-Vary-头" class="headerlink" title="发送 Vary 头"></a>发送 Vary 头</h2><p><code>gzip_vary</code> 指令发送 <code>Vary: Accept-Encoding</code> 头，告知接收方数据经过了压缩，这对于不支持 Gzip 的客户端很有帮助。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><h2 id="使用静态-Gzip-压缩"><a href="#使用静态-Gzip-压缩" class="headerlink" title="使用静态 Gzip 压缩"></a>使用静态 Gzip 压缩</h2><p><code>gzip_static</code> 指令允许 Nginx 直接提供预压缩的文件，而不是在每次请求时动态压缩。这可以显著减少 CPU 使用率，但需要预先生成 <code>.gz</code> 文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><h2 id="预压缩文件"><a href="#预压缩文件" class="headerlink" title="预压缩文件"></a>预压缩文件</h2><p>为了使用 <code>gzip_static</code>，你需要预先生成 <code>.gz</code> 文件。可以使用以下命令生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -c /path/to/file &gt; /path/to/file.gz</span><br></pre></td></tr></table></figure><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h2><p>以下是一个综合的 Nginx Gzip 压缩配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">gzip_disable</span> <span class="string">&quot;MSIE [1-6]\.&quot;</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css text/html application/xml application/json;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /static/ &#123;</span><br><span class="line">            <span class="attribute">root</span> /var/www/html;</span><br><span class="line">            <span class="attribute">gzip_static</span> <span class="literal">on</span>;  <span class="comment"># 对静态文件使用预压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>CPU 资源</strong>：Gzip 压缩会占用 CPU 资源，特别是在高并发环境下。可以通过调整压缩级别和缓存大小来平衡 CPU 使用率和压缩效果。</li><li><strong>预压缩</strong>：对于静态文件，建议使用预压缩来减少 CPU 开销。</li><li><strong>浏览器兼容性</strong>：确保目标浏览器支持 Gzip 压缩，特别是旧版本的浏览器。</li></ol><p>通过以上配置和优化，你可以有效地利用 Gzip 压缩来提升 Nginx 服务器的性能和用户体验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="Gzip压缩" scheme="http://example.com/tags/Gzip%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>4-nginx配置优化</title>
    <link href="http://example.com/2024/11/23/Nginx/4-nginx%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2024/11/23/Nginx/4-nginx%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/</id>
    <published>2024-11-23T05:59:07.000Z</published>
    <updated>2024-12-18T15:44:50.416Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="nginx配置优化"><a href="#nginx配置优化" class="headerlink" title="nginx配置优化"></a>nginx配置优化</h1><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>工作进程配置：<br>worker_processes：设置为与 CPU 核数相同，以充分利用多核处理器。<br>worker_cpu_affinity：为每个工作进程绑定特定的 CPU 核心，减少上下文切换。<br>worker_connections：设置每个工作进程的最大连接数，计算公式为 worker_processes * worker_connections。<br>worker_rlimit_nofile：设置 Nginx 服务器的最大文件描述符数，避免 “too many opened files” 错误。<br> 事件处理模型：<br>use epoll：在 Linux 系统中使用 epoll 事件模型，提高性能。<br>accept_mutex：控制工作进程对新连接的竞争，避免惊群问题。<br>accept_mutex_delay：设置工作进程等待锁的时间，平衡负载。<br>multi_accept：让工作进程一次性接受所有待处理的连接，提高处理效率。<h2 id="日志和错误处理"><a href="#日志和错误处理" class="headerlink" title="日志和错误处理"></a>日志和错误处理</h2>错误日志：<br>error_log：设置错误日志的路径和日志级别，帮助诊断问题。<br>log_format：自定义日志格式，记录更多有用的信息。<br>access_log：设置访问日志的路径和格式，监控访问情况。<h2 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h2>缓存：<br>sendfile：启用 sendfile，直接将文件从文件系统发送到客户端，减少内存拷贝。<br>tcp_nopush：在所有数据准备完毕后一次性发送数据包，减少网络拥塞。<br>open_file_cache：缓存打开的文件描述符，提高静态文件的访问速度。<h2 id="动态内容处理"><a href="#动态内容处理" class="headerlink" title="动态内容处理"></a>动态内容处理</h2>FastCGI 缓存：<br>fastcgi_cache：启用 FastCGI 缓存，减少后端服务器的负载。<br>fastcgi_cache_key：设置缓存键，确保缓存的唯一性。<br>fastcgi_cache_valid：设置缓存的有效时间。<h2 id="安全性和防护"><a href="#安全性和防护" class="headerlink" title="安全性和防护"></a>安全性和防护</h2></li><li>限制请求速率：<br>limit_req：限制客户端的请求速率，防止 DDoS 攻击。<br>limit_conn：限制每个客户端的连接数，防止资源耗尽。</li><li>隐藏版本信息：<br>server_tokens off;：关闭服务器版本信息的显示，提高安全性。<h2 id="SSL-TLS-配置"><a href="#SSL-TLS-配置" class="headerlink" title="SSL/TLS 配置"></a>SSL/TLS 配置</h2></li><li>SSL/TLS 协议和加密套件：<br>ssl_protocols：指定支持的 SSL/TLS 协议版本。<br>ssl_ciphers：指定支持的加密套件。<br>ssl_prefer_server_ciphers on;：优先使用服务器的加密套件。</li><li>证书和密钥：<br>ssl_certificate：指定 SSL 证书文件路径。<br>ssl_certificate_key：指定 SSL 密钥文件路径。<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2>上游服务器配置：<br>upstream：定义后端服务器池，实现负载均衡。<br>least_conn：将请求分配给当前连接数最少的服务器。<br>ip_hash：基于客户端 IP 地址进行会话保持。<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2>代理缓存：<br>proxy_cache：启用代理缓存，减少后端服务器的负载。<br>proxy_cache_key：设置缓存键，确保缓存的唯一性。<br>proxy_cache_valid：设置缓存的有效时间。<h2 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h2></li><li>压缩：<br>gzip：启用 gzip 压缩，减少传输数据量。<br>gzip_types：指定需要压缩的 MIME 类型。<br>gzip_comp_level：设置压缩级别，平衡性能和压缩效果。</li><li>超时设置：<br>keepalive_timeout：设置长连接的超时时间，减少 TCP 握手次数。<br>client_header_timeout：设置客户端头部的超时时间。<br>client_body_timeout：设置客户端请求体的超时时间。</li></ul><h1 id="综合优化Nginx配置示例"><a href="#综合优化Nginx配置示例" class="headerlink" title="综合优化Nginx配置示例"></a>综合优化Nginx配置示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;  # 设置运行 Nginx 的用户为 nginx</span><br><span class="line">worker_processes  auto;  # 自动设置工作进程数量，通常设置为 CPU 核心数</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;  # 每个工作进程允许的最大连接数</span><br><span class="line">    use epoll;  # 使用 epoll 事件模型，提高性能（适用于 Linux）</span><br><span class="line">    accept_mutex on;  # 启用 accept_mutex，避免惊群问题</span><br><span class="line">    accept_mutex_delay 500ms;  # 设置工作进程等待锁的时间，平衡负载</span><br><span class="line">    multi_accept on;  # 让工作进程一次性接受所有待处理的连接，提高处理效率</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;  # 包含 MIME 类型配置文件</span><br><span class="line">    default_type  application/octet-stream;  # 默认 MIME 类型</span><br><span class="line"></span><br><span class="line">    sendfile        on;  # 启用 sendfile，直接将文件从文件系统发送到客户端，减少内存拷贝</span><br><span class="line">    tcp_nopush      on;  # 在所有数据准备完毕后一次性发送数据包，减少网络拥塞</span><br><span class="line">    tcp_nodelay     on;  # 启用 TCP_NODELAY，提高小数据包的传输效率</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;  # 设置长连接的超时时间，减少 TCP 握手次数</span><br><span class="line">    client_header_timeout  10s;  # 设置客户端头部的超时时间</span><br><span class="line">    client_body_timeout  10s;  # 设置客户端请求体的超时时间</span><br><span class="line"></span><br><span class="line">    gzip on;  # 启用 gzip 压缩，减少传输数据量</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/json;  # 指定需要压缩的 MIME 类型</span><br><span class="line">    gzip_comp_level 6;  # 设置压缩级别，平衡性能和压缩效果</span><br><span class="line"></span><br><span class="line">    open_file_cache max=1000 inactive=20s;  # 缓存打开的文件描述符，提高静态文件的访问速度</span><br><span class="line">    open_file_cache_valid 30s;  # 设置缓存的有效时间</span><br><span class="line">    open_file_cache_min_uses 2;  # 文件至少被使用的次数才被缓存</span><br><span class="line">    open_file_cache_errors on;  # 缓存文件打开错误信息</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/access.log combined;  # 设置访问日志的路径和格式，监控访问情况</span><br><span class="line">    error_log /var/log/nginx/error.log warn;  # 设置错误日志的路径和日志级别，帮助诊断问题</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;  # 监听 80 端口</span><br><span class="line">        server_name example.com;  # 设置服务器名称</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html;  # 设置根目录</span><br><span class="line">            index index.html index.htm;  # 设置默认索引文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /api &#123;</span><br><span class="line">            proxy_pass http://backend_server;  # 将请求代理到后端服务器</span><br><span class="line">            proxy_set_header Host $host;  # 设置代理请求头中的 Host 字段</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;  # 设置代理请求头中的 X-Real-IP 字段</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # 设置代理请求头中的 X-Forwarded-For 字段</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;  # 设置代理请求头中的 X-Forwarded-Proto 字段</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;  # 将 PHP 请求传递给 FastCGI 进程</span><br><span class="line">            fastcgi_index index.php;  # 设置默认的 PHP 文件名</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;  # 设置脚本文件路径</span><br><span class="line">            include fastcgi_params;  # 包含 FastCGI 参数配置文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;  # 设置 404 错误页面</span><br><span class="line">        error_page 500 502 503 504 /50x.html;  # 设置 5xx 错误页面</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root /usr/share/nginx/html;  # 设置 5xx 错误页面的根目录</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream backend_server &#123;</span><br><span class="line">        server 192.168.1.101;  # 定义后端服务器地址</span><br><span class="line">        server 192.168.1.102;  # 定义后端服务器地址</span><br><span class="line">        least_conn;  # 使用最少连接数算法进行负载均衡</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;  # 限制每个客户端的请求速率，防止 DDoS 攻击</span><br><span class="line">    limit_conn_zone $binary_remote_addr zone=addr:10m;  # 限制每个客户端的连接数，防止资源耗尽</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;  # 指定支持的 SSL/TLS 协议版本</span><br><span class="line">    ssl_ciphers &#x27;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES256-GCM-SHA384&#x27;;  # 指定支持的加密套件</span><br><span class="line">    ssl_prefer_server_ciphers on;  # 优先使用服务器的加密套件</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;  # 监听 443 端口，并启用 SSL</span><br><span class="line">        server_name example.com;  # 设置服务器名称</span><br><span class="line"></span><br><span class="line">        ssl_certificate /etc/nginx/ssl/example.com.crt;  # 指定 SSL 证书文件路径</span><br><span class="line">        ssl_certificate_key /etc/nginx/ssl/example.com.key;  # 指定 SSL 密钥文件路径</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html;  # 设置根目录</span><br><span class="line">            index index.html index.htm;  # 设置默认索引文件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx配置优化" scheme="http://example.com/tags/nginx%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>3-nginx服务配置</title>
    <link href="http://example.com/2024/11/22/Nginx/3-nginx%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/11/22/Nginx/3-nginx%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</id>
    <published>2024-11-22T06:30:08.000Z</published>
    <updated>2024-12-18T15:44:31.493Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h1><p>/etc/nginx/nginx.conf为主配置文件，主配置文件，配置文件必须以<code>;</code>结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;    #全局快</span><br><span class="line">events &#123;     # events块</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;     #http块</span><br><span class="line">    include       mime.types;   # 加载MIME类型配置文件</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;     # server块</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;   #localtion块</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;     #localtion块</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局块:配置文件从开始到events块之间的，通常包括worker process数、nginx进程PID的存放路径、日志存放路径  </li><li>events块：主要影响nginx服务器与用户的网络连接，对nginx服务器性能影响对较大。  </li><li>http块：代理、缓存、日志定义等，可以嵌套server块、location块  </li><li>server块：每一个server块相当于一台虚拟主机，端口、域名、根目录、错误页面  </li><li>location块：定义针对特定URL路径的处理规则，位于server块内部，可以根据路径匹配规则进行反向代理、静态文件服务  </li><li>stream:配置TCP/UDP的代理设置  </li><li>mail：配置邮件代理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">全局块</span><br><span class="line">└── events块</span><br><span class="line">└── http块</span><br><span class="line">    └── server块</span><br><span class="line">        └── location块</span><br><span class="line">└── mail块（可选）</span><br><span class="line">└── stream块（可选）</span><br></pre></td></tr></table></figure></li></ul><p>配置讲解  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user USER  [GROUP]，配置运行nginx的用户和用户组，注释或者nobody为所有用户都可执行  </span></span><br><span class="line"><span class="comment">#只能在全局块中使用  </span></span><br><span class="line"><span class="comment">#user  nobody;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#工作进程的数量，配置的大小与CPU核数相关，可以设置为auto，表示自动设置为CPU核心数</span></span><br><span class="line"><span class="comment">#只能在全局块中使用</span></span><br><span class="line">worker_processes  auto<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置每个工作进程的最大文件描述符数量</span></span><br><span class="line">worker_rlimit_nofile 10240<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误日志级别，可以根据需要调整为 debug, info, notice, warn, error, crit, alert, emerg</span></span><br><span class="line"><span class="comment"># de<span class="doctag">bug:</span> 最详细的日志信息，包括调试信息</span></span><br><span class="line"><span class="comment"># info: 一般的信息性消息</span></span><br><span class="line"><span class="comment"># notice: 比info更严重的消息，但不是错误</span></span><br><span class="line"><span class="comment"># warn: 警告信息，表示可能的问题</span></span><br><span class="line"><span class="comment"># error: 错误信息，表示出现问题，但不影响服务继续运行</span></span><br><span class="line"><span class="comment"># crit: 严重错误信息，表示可能导致某些功能失效</span></span><br><span class="line"><span class="comment"># alert: 紧急情况，需要立即关注</span></span><br><span class="line"><span class="comment"># emerg: 紧急情况，系统不可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;   #记录notice以及更严重级别</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#PID文件存放路径</span></span><br><span class="line"><span class="comment">#只能在全局块中使用</span></span><br><span class="line"><span class="comment">#pid  logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#单个工作进程可以允许同时建立外部连接的数量，默认为512</span></span><br><span class="line">    worker_connections  1024<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#互斥锁，防止多个进程对访问连接的争抢，确保每次只有一个工作进程可以接收新连接</span></span><br><span class="line">    <span class="comment">#打开互斥锁可以减少惊群（避免所有工作进程在接收到新连接通知时都试图接受连接，导致系统资源浪费）、</span></span><br><span class="line">    <span class="comment">#高并发情况中建议关闭，以提高性能</span></span><br><span class="line">    <span class="comment">#只能在events块中进行设置,默认为开启状态</span></span><br><span class="line">    <span class="comment">#accept_mutex  on</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#让nginx worker进程尽可能多地接受请求，worker进程一次性地接受监听队列里的所有请求，然后处理</span></span><br><span class="line">    <span class="comment">#高并发情况中建议打开</span></span><br><span class="line">    <span class="comment">#multi_accept on/off;    #默认为off</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#选择事件模型进行消息处理</span></span><br><span class="line">    <span class="comment">#method可选择内容有：select（支持最多1024个文件描述符，适用于所有操作系统）、poll（支持更多的文件描述符，没有数量限制，适用于需要处理大量连接的操作系统）、epoll（linux中推荐，性能更好）</span></span><br><span class="line">    use epoll<span class="comment">; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">#include 表示将其他nginx配置或者第三方模块引用到主配置文件</span></span><br><span class="line">    <span class="comment">#mime.types定义不同文件扩展名对应的MIME类型</span></span><br><span class="line">    include       mime.types<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#默认的MIME类型</span></span><br><span class="line">    <span class="comment">#application/octet-stream表示二进制数据流</span></span><br><span class="line">    default_type  application/octet-stream<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义服务日志的格式，并为格式定一个名字</span></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line">    <span class="comment">#自定义服务日志，access_log path [format [buffer=size]]</span></span><br><span class="line">    <span class="comment">#format为log_format中定义的定义好的格式名称，size为临时存放日志的缓存区的大小</span></span><br><span class="line">    access_log /var/log/nginx/access.log main<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#配置是否允许使用sendfile传输文件</span></span><br><span class="line">    <span class="comment">#启用 sendfile，Nginx 可以直接将文件从文件系统发送到客户端，而不需要先将文件读取到内存中，然后再发送给客户端。</span></span><br><span class="line">    <span class="comment">#可以显著减少 CPU 使用率和提高传输效率</span></span><br><span class="line">    sendfile        on<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#每个工作进程每次调用sendfile传输的数据量最大值</span></span><br><span class="line">    sendfile_max_chunk 1m<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#nginx可以在所有数据准备完毕后一次性发送一个完成的数据包，而不是频繁的发送小的数据包。</span></span><br><span class="line">    <span class="comment">#减少网络拥塞和提高传输效率</span></span><br><span class="line">    tcp_nopush     on<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive超时时间</span></span><br><span class="line">    keepalive_timeout  65<span class="comment">;</span></span><br><span class="line">    <span class="comment">#限制用户某一连接的请求次数，默认为100</span></span><br><span class="line">    <span class="comment">#keepalive_requests NUMBER;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip压缩功能是够开启，是将网页静态资源压缩后传输到浏览器在进行解压，会消耗一定CPU资源，但会提高访问速度</span></span><br><span class="line">    gzip on<span class="comment">;</span></span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/json<span class="comment">;</span></span><br><span class="line">    gzip_comp_level 6<span class="comment">; # 压缩等级，范围1-9，数值越大压缩比越高，但消耗更多CPU</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置代理缓存路径、大小和过期时间</span></span><br><span class="line">    proxy_cache_path /var/cache/nginx <span class="attr">levels</span>=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10</span>m max_size=<span class="number">1</span>g inactive=<span class="number">60</span>m use_temp_path=<span class="literal">off</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求速率限制，防止DDoS攻击</span></span><br><span class="line">    limit_req_zone $binary_remote_addr <span class="attr">zone</span>=<span class="literal">on</span>e:<span class="number">10</span>m rate=<span class="number">1</span>r/s<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#监听所有IP 80端口</span></span><br><span class="line">        <span class="comment">#listen IP 监听具体IP的80端口、listen PORT 监听所有IP的指定端口</span></span><br><span class="line">        <span class="comment">#相当于listen *:80;</span></span><br><span class="line">        listen       80<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#指定了请求的目标主机名或IP地址，Nginx 会从请求头中提取 Host 字段的值，用于匹配 server_name 配置。</span></span><br><span class="line">        <span class="comment">#对外提供的虚拟机；接受请求的域名、IP，由两段或者三段组成，demo.com  www.demo.com</span></span><br><span class="line">        <span class="comment">#可以有多个名，之间用空格隔开，第一个为主名;可以使用通配符*，但是只能在三段的首段或者尾段使用</span></span><br><span class="line">        <span class="comment">#server_name _; 表示匹配任何主机名</span></span><br><span class="line">        server_name  localhost<span class="comment">;</span></span><br><span class="line">        <span class="comment">#server_name  ~^www\d+\.myserver\.com$;  </span></span><br><span class="line">        <span class="comment">#还可以使用正则表达式，~表示正则表达式的开始  </span></span><br><span class="line">        <span class="comment">#匹配优先级为：精确匹配&gt;左通配符（*.example.com）&gt;右通配符（www.*）&gt;正则&gt;默认服务器</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># location [=/^~/~、~*/] 请求字符串，优先级高--底</span></span><br><span class="line">        <span class="comment"># =: 精确匹配</span></span><br><span class="line">        <span class="comment"># ^~: 如果匹配成功，则停止搜索其他正则表达式。</span></span><br><span class="line">        <span class="comment"># ~: 区分大小写的正则表达式匹配。</span></span><br><span class="line">        <span class="comment"># ~*: 不区分大小写的正则表达式匹配。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用正则必必须用标识 ~ 字符串包含正则，区分大小写 、 ~* 字符串包含正则，不区分大小写</span></span><br><span class="line">        location / &#123;  <span class="comment">#  通用匹配, 如果没有其它匹配,任何请求都会匹配到。</span></span><br><span class="line">            <span class="comment"># 请求的根目录，此处为nginx下的html目录，相对路径为相对nginx安装目录</span></span><br><span class="line">            root   html<span class="comment">;    #访问地址为 server_name/location字符串    访问文件路径为 root值/location字符串</span></span><br><span class="line">            index  index.html index.htm<span class="comment">;  #index 为默认首页</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#location /demo &#123;       #根据servername为localhost，当访问 localhost/demo时访问的文件为 /opt/demo下的文件</span></span><br><span class="line">        <span class="comment">#    root   /opt;               #还可以使用alisa更改，例如 alisa /opt/test;   实际访问的文件就是/opt/test下的文件</span></span><br><span class="line">        <span class="comment">#    index index.html;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#设置网站的错误页面，error_page ERROR_CODE  PATH</span></span><br><span class="line">        <span class="comment">#ERROR_CODE为错误代码，多个代码之间用空格隔出</span></span><br><span class="line">        <span class="comment">#PATH为nginx安装目录html为根目录的相对路径，若不想将错误页面放在nginx安装目录，可以后面跟一个location模块重新定向到目录</span></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html<span class="comment">;</span></span><br><span class="line">        <span class="attr">location</span> = /<span class="number">50</span>x.html &#123;</span><br><span class="line">            root   html<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx服务配置" scheme="http://example.com/tags/nginx%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>2-nginx安装</title>
    <link href="http://example.com/2024/11/21/Nginx/2-nginx%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2024/11/21/Nginx/2-nginx%E5%AE%89%E8%A3%85/</id>
    <published>2024-11-21T07:40:13.000Z</published>
    <updated>2024-12-31T06:14:46.227Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg">  </p><span id="more"></span><h1 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h1><p>nginx安装有yum安装与编译安装，yum安装无法自定义、安装时无法添加模块，编译安装安装位置与模块都可以自定义，但是需要安装依赖。  </p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>从nginx官网下载安装包，Mainline version是主线版本也就是开发版本，Stable version是稳定版、Legacy versions历史版本。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span>  </span><br><span class="line">yum install -y gcc gcc-c++ make automake autoconf libtool pcre* zlib openssl openssl-devel</span><br><span class="line">tar zxvf nginx-1.22.1.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local/nginx-1.22.1</span><br><span class="line">./configure   #暂不指定参数</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后默认的nginx安装位置在/usr/local/nginx，相关的配置文件都在该位置。  </p><h3 id="将nginx添加为系统服务"><a href="#将nginx添加为系统服务" class="headerlink" title="将nginx添加为系统服务"></a>将nginx添加为系统服务</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># /usr/lib/systemd/system/nginx.service</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=nginx web service</span><br><span class="line"><span class="attr">Documentation</span>=http://nginx.org/en/docs/</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">PIDFile</span>=/usr/local/nginx/logs/nginx.pid</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/nginx/sbin/nginx</span><br><span class="line"><span class="attr">ExecReload</span>=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure><h2 id="使用yum-dnf安装"><a href="#使用yum-dnf安装" class="headerlink" title="使用yum/dnf安装"></a>使用yum/dnf安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum/dnf install -y nginx nginx-mod-stream </span><br></pre></td></tr></table></figure><h2 id="nginx服务启停"><a href="#nginx服务启停" class="headerlink" title="nginx服务启停"></a>nginx服务启停</h2><p>/usr/local/nginx/sbin/nginx相关参数<br>-v V：打印版本号、和配置<br>-t：测试配置正确性<br>-q：测试时只显示错误<br>-s：向主进程发送信号，stop（快速关机）、quit（优雅关机）、reopen（重新打开日志文件）、reload（重新加载配置文件）<br>-c：指定nginx配置文件路径<br>-g：指定nginx附加配置文件路径  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx安装" scheme="http://example.com/tags/nginx%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>1-nginx相关概念</title>
    <link href="http://example.com/2024/11/20/Nginx/1-nginx%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2024/11/20/Nginx/1-nginx%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2024-11-20T04:11:30.000Z</published>
    <updated>2024-12-18T15:44:17.305Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg" alt="nginx.jpg"></p><span id="more"></span><p><a href="https://docs.nginx.com/nginx/">nginx官网文档</a>、<a href="https://nginx.org/en/docs/dirindex.html">nginx指令索引</a>  </p><h1 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h1><p>Nginx是一个高性能的HTTP和反向代理web服务器，也是一个IMAP、POP3、SMTP服务器，特点是占用内存少，并发性能强。  </p><h2 id="Nginx作为web服务器"><a href="#Nginx作为web服务器" class="headerlink" title="Nginx作为web服务器"></a>Nginx作为web服务器</h2><p>Nginx可以作为静态页面的web服务器，异步非阻塞，使用IO多路复用的epoll模型。  </p><h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><p><strong>同步与异步是通信模式的概念</strong><br>同步：发送方发送请求后，等待请求响应，才继续发送下一个请求<br>异步：发送方发送请求后，不需要等待响应，就继续发送下一个请求<br><strong>阻塞与非阻塞是进程处理调用的方式</strong><br>阻塞：结果返回之前线程处于挂起状态<br>非阻塞：线程不会被挂起，立即执行返回下一个调用  </p><h2 id="正向代理（代理的是客户端）"><a href="#正向代理（代理的是客户端）" class="headerlink" title="正向代理（代理的是客户端）"></a>正向代理（代理的是客户端）</h2><p>客户端想要访问一个服务器，但是它可能无法直接访问这台服务器，这时候这可找一台可以访问目标服务器的另外一台服务器，而这台服务器就被当做是代理人的角色 ，称之为代理服务器，于是客户端把请求发给代理服务器，由代理服务器获得目标服务器的数据并返回给客户端。客户端是清楚目标服务器的地址的，而目标服务器是不清楚来自客户端，它只知道来自哪个代理服务器，所以正向代理可以屏蔽或隐藏客户端的信息。  </p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p><strong>访问被禁止的资源</strong>：让客户端访问原来不能访问的服务器，通过代理服务器进行访问。<br><strong>隐藏客户端的地址</strong>：代理服务器代表了客户端，看不到原始的客户端。<br><strong>进行客户访问控制</strong>：集中部署访问策略，控制客户端的访问行为，内部资源的控制。<br><strong>加速访问资源</strong>：代理服务器设置一个较大的缓冲区，会将部分请求的响应保存到缓冲区，其他用户访问时可以从缓冲区域直接读取信息。  </p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>客户端配置代理服务器：客户端配置代理服务器的地址和端口。</li><li>客户端发送请求：客户端将请求发送到代理服务器。</li><li>代理服务器转发请求：代理服务器根据请求中的目标地址，将请求转发到目标服务器。</li><li>目标服务器响应：目标服务器处理请求并返回响应。</li><li>代理服务器返回响应：代理服务器将目标服务器的响应返回给客户端</li></ol><h2 id="反向代理（代理的是服务器）"><a href="#反向代理（代理的是服务器）" class="headerlink" title="反向代理（代理的是服务器）"></a>反向代理（代理的是服务器）</h2><p>反向代理就是代理服务器为服务器作代理人，站在服务器这边，它就是对外屏蔽了服务器的信息，常用的场景就是多台服务器分布式部署，像一些大的网站，由于访问人数很多，就需要多台服务器来解决人数多的问题，这时这些服务器就由一个反向代理服务器来代理，客户端发来请求，先由反向代理服务器，然后按一定的规则分发到明确的服务器，而客户端不知道是哪台服务器。  </p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p><strong>隐藏服务器的IP</strong>：因为反向代理服务器代理了服务器所以客户端并不知道业务服务器的IP。<br><strong>负载均衡</strong>：反向代理服务器根据业务服务器的负载情况，将客户端的请求分别发送到不同的业务服务器。<br><strong>提高访问速度</strong>：对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务。<br><strong>提供安全保障</strong>：对网站提供基于WEB攻击的防护、为后端提供加密和SSL加速、提供HTTP访问认证。  </p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>客户端发送请求：客户端将请求发送到代理服务器。</li><li>代理服务器转发请求：代理服务器根据配置将请求转发到后端服务器。</li><li>后端服务器响应：后端服务器处理请求并返回响应。</li><li>代理服务器返回响应：代理服务器将后端服务器的响应返回给客户端。</li></ol><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>单个服务器解决不了时，增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。  </p><h3 id="常见负载均衡算法"><a href="#常见负载均衡算法" class="headerlink" title="常见负载均衡算法"></a>常见负载均衡算法</h3><ul><li><strong>轮询（Round Robin）</strong>：依次将请求分发到各个服务器。</li><li><strong>加权轮询（Weighted Round Robin）</strong>：根据服务器的权重分配请求，权重高的服务器会分配到更多的请求。</li><li><strong>最少连接数（Least Connections）</strong>：将请求分配给当前连接数最少的服务器。</li><li><strong>IP哈希（IP Hash）</strong>：根据客户端的IP地址进行哈希运算，将请求分配到固定的服务器，实现会话保持。</li><li><strong>一致性哈希（Consistent Hashing）</strong>：通过一致性哈希算法将请求分配到服务器，减少因服务器增减而导致的缓存失效。</li></ul><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。  </p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>提高性能：静态内容由专门的服务器处理，减少动态服务器的负担。</li><li>简化管理：静态和动态内容分开管理，便于维护和优化。</li><li>提高安全性：静态内容服务器可以配置更严格的访问控制，减少安全风险。<h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3></li></ul><ol><li>客户端发送请求：客户端发送请求到 Nginx 服务器。</li><li>Nginx 分发请求：Nginx 根据请求的 URL 路径，将静态内容请求分发到静态服务器，将动态内容请求分发到动态服务器。</li><li>服务器响应：静态服务器和动态服务器分别处理请求并返回响应。</li><li>Nginx 返回响应：Nginx 将服务器的响应返回给客户端。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/27/xdGY8aqytLheSjp.jpg&quot; alt=&quot;nginx.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://example.com/categories/nginx/"/>
    
    
    <category term="nginx相关概念" scheme="http://example.com/tags/nginx%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>4-事件通知</title>
    <link href="http://example.com/2024/11/07/zabbix/4-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5/"/>
    <id>http://example.com/2024/11/07/zabbix/4-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5/</id>
    <published>2024-11-07T11:49:12.000Z</published>
    <updated>2024-12-19T02:44:13.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/03/25/BC4LOAv1sp89SnY.jpg" alt="zabbix.jpg">  </p><span id="more"></span><h1 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h1><p>在配置了诸多监控项和触发器，并且在触发器状态发生变化的情况下，用户已经接收到了一些告警信息，那么接下来就要考虑通过配置动作（actions）来响应事件的发生。<br>配置流程：配置媒介-配置动作-</p><h2 id="定义媒介"><a href="#定义媒介" class="headerlink" title="定义媒介"></a>定义媒介</h2><p>在告警 → 媒介类型中定义媒介  </p><h3 id="电子邮箱"><a href="#电子邮箱" class="headerlink" title="电子邮箱"></a>电子邮箱</h3><p>可以使用媒介中预制的电子邮件模板进行配置<br><img src="/2024/11/07/zabbix/4-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5/2024-11-12-20-09-33.png"><br>填写SMTP服务器、电子邮件（用作发送邮件的发件人地址），填写用户名名与密码。</p><h3 id="企业微信"><a href="#企业微信" class="headerlink" title="企业微信"></a>企业微信</h3><ol><li>在要接受告警信息的企业微信群中添加群机器人，获取到机器人的webhook地址。</li><li>在zabbix server端查看配置文件中<strong>AlertScriptsPath</strong>的默认路径，并在指定路径下创建脚本 wecom-webhook.py。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">headers=&#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>&#125;</span><br><span class="line">api_url=<span class="string">&quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxxxxxxxxxxxxxx&quot;</span>   <span class="comment">#替换为群机器人的webhook地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msg</span>(<span class="params">text</span>):</span></span><br><span class="line">    json_text=&#123;</span><br><span class="line">     <span class="string">&quot;msgtype&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    requests.post(api_url,json.dumps(json_text),headers=headers)    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = sys.argv[<span class="number">1</span>]</span><br><span class="line">msg(text)</span><br></pre></td></tr></table></figure>测试脚本是否无误，企业微信是否可以接收到信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wecom-webhook.py &quot;测试告警信息&quot;</span><br></pre></td></tr></table></figure></li><li>在zabbix web中克隆一个告警媒介类型，并修改为企业微信<br>脚本参数中填写 <strong>{ALERT.MESSAGE}</strong><br><img src="/2024/11/07/zabbix/4-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5/2024-11-15-15-24-48.png"></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/25/BC4LOAv1sp89SnY.jpg&quot; alt=&quot;zabbix.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="zabbix" scheme="http://example.com/categories/zabbix/"/>
    
    
    <category term="zabbix事件通知" scheme="http://example.com/tags/zabbix%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>修改IP</title>
    <link href="http://example.com/2024/10/14/Linux/%E4%BF%AE%E6%94%B9IP/"/>
    <id>http://example.com/2024/10/14/Linux/%E4%BF%AE%E6%94%B9IP/</id>
    <published>2024-10-14T06:36:38.000Z</published>
    <updated>2024-10-22T06:10:22.376Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/02/cX51yi4KrLYRfJU.jpg">  </p><span id="more"></span><h1 id="修改rocky-IP"><a href="#修改rocky-IP" class="headerlink" title="修改rocky IP"></a>修改rocky IP</h1><h2 id="方式一：使用nmtui修改IP"><a href="#方式一：使用nmtui修改IP" class="headerlink" title="方式一：使用nmtui修改IP"></a>方式一：使用nmtui修改IP</h2><p>   使用nmtui修改相关配置后需要重启相应的服务  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli c reload </span><br><span class="line">nmcli c up ens160</span><br></pre></td></tr></table></figure><h2 id="方式二：修改配置文件"><a href="#方式二：修改配置文件" class="headerlink" title="方式二：修改配置文件"></a>方式二：修改配置文件</h2><p>修改配置文件 <strong>/etc/NetworkManager/system-connections/ens160.nmconnection</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">id=ens160</span><br><span class="line">uuid=fe2790ee-f7e6-3ae2-a498-93fb0c0ecde5</span><br><span class="line">type=ethernet</span><br><span class="line">autoconnect-priority=-999</span><br><span class="line">interface-name=ens160</span><br><span class="line">timestamp=1728719120</span><br><span class="line"></span><br><span class="line">[ethernet]</span><br><span class="line"></span><br><span class="line">[ipv4]</span><br><span class="line">address1=192.168.27.5/24,192.168.27.2    IP/掩码,网关</span><br><span class="line">dns=8.8.8.8;</span><br><span class="line">method=manual</span><br><span class="line"></span><br><span class="line">[ipv6]</span><br><span class="line">addr-gen-mode=eui64</span><br><span class="line">method=auto</span><br><span class="line"></span><br><span class="line">[proxy]</span><br></pre></td></tr></table></figure><p>修改完成后重启网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli c reload </span><br><span class="line">nmcli c up ens160</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/02/cX51yi4KrLYRfJU.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="修改IP" scheme="http://example.com/tags/%E4%BF%AE%E6%94%B9IP/"/>
    
  </entry>
  
  <entry>
    <title>容器运行时</title>
    <link href="http://example.com/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    <id>http://example.com/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/</id>
    <published>2024-09-10T15:40:35.000Z</published>
    <updated>2024-10-22T07:19:52.300Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6.jpg">  </p><span id="more"></span><h2 id="容器运行时是什么"><a href="#容器运行时是什么" class="headerlink" title="容器运行时是什么"></a>容器运行时是什么</h2><p>容器运行时（Container Runtime）是容器化技术中的关键组件之一，它负责运行容器。容器运行时管理容器的生命周期，包括创建、启动、停止以及销毁容器等操作。  </p><h2 id="容器运行时种类"><a href="#容器运行时种类" class="headerlink" title="容器运行时种类"></a>容器运行时种类</h2><p><strong>docker</strong>：这可能是最为人所知的容器运行时。Docker 通过简化容器的创建和管理，使得容器技术变得更加易用。<br><strong>containerd</strong>：是从 Docker 中分离出来的一个项目，可以作为一个底层容器运行时，现在它成了Kubernete 容器运行时更好的选择。containerd 是一个高级的容器运行时，它强调简单性、稳定性和可移植性，可以直接被用于Docker和其他系统。containerd 是真正管控容器的一个进程，执行容器的时候用的是 runc。<br><strong>runc</strong>：runc：是一个轻量级的工具，它是containerd的一部分，用于根据OCI（Open Container Initiative）标准创建和运行容器。runc 直接在操作系统上运行容器，是containerd和CRI-O等更高级运行时的底层运行时。<br><strong>CRI-O</strong>：也是CNCF的一个项目，它是一个轻量级的容器运行时，专门用于Kubernetes。CRI-O 直接实现了Kubernetes的容器运行时接口（CRI），不依赖于Docker或其他容器引擎。  </p><h2 id="什么是OCI"><a href="#什么是OCI" class="headerlink" title="什么是OCI"></a>什么是OCI</h2><p>OCI 是一个开放的容器标准，定义了容器的运行时规范（runtime specification）和映像规范（image specification）。Docker 以及其他一些容器平台实际上使用的都是 runc 或其他兼容 OCI 规范的工具来创建和运行容器。</p><h2 id="什么是CRI"><a href="#什么是CRI" class="headerlink" title="什么是CRI"></a>什么是CRI</h2><p>CRI本质上就是 Kubernetes 定义的一组与容器运行时进行交互的接口，所以只要实现了这套接口的容器运行时都可以对接到 Kubernetes 平台上来。不过 Kubernetes 推出 CRI 这套标准的时候还没有现在的统治地位，所以有一些容器运行时可能不会自身就去实现 CRI 接口，于是就有了 shim（垫片）， 一个 shim 的职责就是作为适配器将各种容器运行时本身的接口适配到 Kubernetes 的 CRI 接口上，其中 dockershim 就是 Kubernetes 对接 Docker 到 CRI 接口上的一个垫片实现。  </p><p>Kubernetes最新版本(v1.24+)宣布弃用 dockershim，移除了对Docker作为容器运行时的原生支持,但这并不意味着完全不支持Docker。<br>Kubernetes仍然支持使用Docker镜像。所有现有的Docker镜像可以直接用在k8s集群中,不需要修改。<br>Kubernetes已经全面拥抱容器运行时接口(CRI)。最新版本的kubelet将通过CRI管理容器,而不是直接通过Docker API。<br>用户可以继续使用Docker作为CRI运行时。只需要安装并配置Docker的CRI插件,即docker-containerd插件,kubelet就可以通过CRI控制Docker。<br>推荐的容器运行时是containerd。它功能丰富,性能好,资源消耗少。docker-containerd确保它可以与Docker镜像兼容。<br>切换到containerd后,节点上仍可以同时运行Docker引擎,用于构建镜像等场景。<br>Kubernetes移除Docker的依赖可以使其支持更多类型的容器运行时,提高其可移植性。</p><h2 id="docker容器运行时"><a href="#docker容器运行时" class="headerlink" title="docker容器运行时"></a>docker容器运行时</h2><p>在 Docker 中，当你运行一个容器时（例如使用 docker run 命令），Docker 会调用 runc（或 Docker 的默认运行时）来实际创建和启动容器。runc 是一个底层的工具，对于大多数 Docker 用户来说，通常不需要直接与 runc 交互。<br><img src="/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/2024-09-11-15-04-48.png">  </p><p>当我们要创建一个容器的时候，现在 Docker Daemon 并不能直接帮我们创建了，而是请求 containerd 来创建一个容器，containerd 收到请求后，也并不会直接去操作容器，而是创建一个叫做 containerd-shim 的进程，让这个进程去操作容器，我们指定容器进程是需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作的，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，而引入 containerd-shim 这个垫片就可以来规避这个问题了。  </p><p>然后创建容器需要做一些 namespaces 和 cgroups 的配置，以及挂载 root 文件系统等操作，这些操作其实已经有了标准的规范，那就是 OCI（开放容器标准），runc 就是它的一个参考实现（Docker 被逼无耐将 libcontainer 捐献出来改名为 runc 的），这个标准其实就是一个文档，主要规定了容器镜像的结构、以及容器需要接收哪些操作指令，比如 create、start、stop、delete 等这些命令。runc 就可以按照这个 OCI 文档来创建一个符合规范的容器，既然是标准肯定就有其他 OCI 实现，比如 Kata、gVisor 这些容器运行时都是符合 OCI 标准的。  </p><p>所以真正启动容器是通过 containerd-shim 去调用 runc 来启动容器的，runc 启动完容器后本身会直接退出，containerd-shim 则会成为容器进程的父进程，负责收集容器进程的状态，上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理，确保不会出现僵尸进程。</p><p><img src="/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/2024-09-11-15-09-27.png">  </p><p>现在如果我们使用的是 Docker 的话，当我们在 Kubernetes 中创建一个 Pod 的时候，首先就是 kubelet 通过 CRI 接口调用 dockershim，请求创建一个容器，kubelet 可以视作一个简单的 CRI Client, 而 dockershim 就是接收请求的 Server，不过他们都是在 kubelet 内置的。  </p><p>dockershim 收到请求后，转化成 Docker Daemon 能识别的请求，发到 Docker Daemon 上请求创建一个容器，请求到了 Docker Daemon 后续就是 Docker 创建容器的流程了，去调用 containerd，然后创建 containerd-shim 进程，通过该进程去调用 runc 去真正创建容器。  </p><p>其实我们仔细观察也不难发现使用 Docker 的话其实是调用链比较长的，真正容器相关的操作其实 containerd 就完全足够了，Docker 太过于复杂笨重了，当然 Docker 深受欢迎的很大一个原因就是提供了很多对用户操作比较友好的功能，但是对于 Kubernetes 来说压根不需要这些功能，因为都是通过接口去操作容器的，所以自然也就可以将容器运行时切换到 containerd 来。<br><img src="/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/2024-09-11-15-11-31.png">  </p><p>在 k8s v1.24 以后需要额外安装 cri-dockerd, k8s 才能够正常识别到 Docker。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/09/10/K8s/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PXE批量部署</title>
    <link href="http://example.com/2024/09/03/Linux/PXE%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2024/09/03/Linux/PXE%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2/</id>
    <published>2024-09-03T07:52:20.000Z</published>
    <updated>2024-09-03T07:52:20.968Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux测试工具</title>
    <link href="http://example.com/2023/08/04/Linux/Linux%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2023/08/04/Linux/Linux%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</id>
    <published>2023-08-04T07:50:19.000Z</published>
    <updated>2023-08-04T08:00:36.087Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/02/cX51yi4KrLYRfJU.jpg" alt="linux.jpg">  </p><span id="more"></span><h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><h2 id="SPEC-CPU"><a href="#SPEC-CPU" class="headerlink" title="SPEC CPU"></a>SPEC CPU</h2><p>SPEC CPU套件包括了一组性能测试程序，用于衡量计算机系统处理器在不同工作负载下的性能表现。这些测试程序涵盖了常见的计算密集型任务，如浮点运算、整数运算、存储访问等。<br>SPEC CPU测试结果以 SPECint 和 SPECfp 两个主要指标来衡量，分别代表了计算系统在整数和浮点运算方面的性能。这些指标可以用来比较不同系统的性能，并提供了参考数据，帮助用户选择适合自己需求的计算机系统。<br>SPEC CPU套件有不同的版本可供选择，包括SPEC CPU2006和SPEC CPU2017等。<br>SPEC CPU2006是SPEC CPU套件的旧版本，于2006年发布。它包含一系列测试程序，用于评估计算机系统处理器在整数和浮点运算方面的性能。<br>SPEC CPU2017是SPEC CPU套件的最新版本，于2017年发布。与SPEC CPU2006相比，SPEC CPU2017引入了新的工作负载和测试程序，以反映当今计算机系统的计算需求和技术进步。SPEC CPU2017比SPEC CPU2006更加现代化，能够更准确地评估计算机系统的性能。<br>SPEC CPU2006和SPEC CPU2017之间存在一些区别和关系：</p><ul><li>工作负载：SPEC CPU2006包含12个基准测试程序，而SPEC CPU2017包含了17个基准测试程序。  </li><li>测试程序选择：SPEC CPU2017选择了新的测试程序，更加关注现代计算需求，例如虚拟化、多线程处理等。  </li><li>指标：SPEC CPU2006使用的是SPECint2006和SPECfp2006两个指标来衡量性能，而SPEC CPU2017使用的是SPECrate2017_int和SPECrate2017_fp两个指标。  </li><li>测试环境：SPEC CPU2017对测试环境的要求更加严格，以确保测试的可靠性和准确性。  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/02/cX51yi4KrLYRfJU.jpg&quot; alt=&quot;linux.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>概念补充知识</title>
    <link href="http://example.com/2023/07/27/Linux/%E6%A6%82%E5%BF%B5%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2023/07/27/Linux/%E6%A6%82%E5%BF%B5%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</id>
    <published>2023-07-27T09:31:59.000Z</published>
    <updated>2023-08-23T10:04:31.238Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/02/cX51yi4KrLYRfJU.jpg">  </p><span id="more"></span><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><p><img src="/2023/07/27/Linux/%E6%A6%82%E5%BF%B5%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png">  </p><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>用户态和内核态是两种不同的特权级别，用于区分进程执行时的权限和资源访问的范围，这是操作系统的核心概念之一，有助于保护系统的稳定性和安全性。  </p><h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>用户态是进程执行时的一种受限状态，进程在用户态下运行时，只能访问受限的资源和执行受限的操作。在用户态下，进程不能直接访问操作系统的底层资源，如内存管理单元，硬件设备、中断处理等。如果进程需要执行需要更高权限的操作或访问受限资源，它必须通过系统调用来请求内核的帮助。<br>在用户态下，进程运行的代码通常是应用程序代码，如用户编写的应用程序或库。用户态的代码执行速度较快，但受到操作系统的限制，无法直接操作硬件设备或访问核心资源。   </p><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>内核态是进程执行时的特权状态，进程在内核态下拥有访问操作系统核心资源和执行特权操作的权限。在内核态下，进程可以执行任意指令，包括访问所有硬件设备、执行特权指令、直接操作内存等。内核态的代码通常是操作系统内核代码。  </p><h2 id="软中断与硬中断"><a href="#软中断与硬中断" class="headerlink" title="软中断与硬中断"></a>软中断与硬中断</h2><p><strong>中断</strong>指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。  </p><h3 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h3><p>硬中断是由计算机硬件发出的中断信号，用于向处理器通知某个特定事件的发生，如外部设备请求处理、定时器中断、硬件故障等。硬件中断是异步的，即发生中断的时间点是不可预测的，处理器必须立即中止当前正在执行的任务并跳转到中断服务例程来处理中断请求。硬中断使用硬件中断向量来识别和处理不同类型的中断。<br>硬中断的触发可以由外部设备、CPU内部的定时器或其他硬件组件引起。处理器在接收到硬中断信号后，会根据硬件中断向量找到对应的中断处理程序，并在处理完中断后返回到被中断的程序。  </p><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>软中断是由计算机软件（通常是运行在用户空间的程序或操作系统内核代码）主动触发的中断。软中断是通过特定的指令来引发的，例如在x86架构的CPU中，使用INT指令产生软中断。软中断通常用于实现系统调用（System Call）和在用户空间和内核空间之间传递消息或请求。<br>软中断是同步的，即由程序主动发起，因此它们不会像硬中断那样随机发生。软中断的使用可以在用户态和内核态之间切换，并允许用户程序请求操作系统的服务和资源。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><h2 id="内存相关概念"><a href="#内存相关概念" class="headerlink" title="内存相关概念"></a>内存相关概念</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/02/cX51yi4KrLYRfJU.jpg&quot;&gt;  &lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="补充知识" scheme="http://example.com/tags/%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
